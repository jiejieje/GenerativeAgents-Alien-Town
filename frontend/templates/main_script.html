<!-- 优先尝试本地 PixiJS 与 tilemap（离线/内网可用），再由脚本做 CDN 兜底 -->
<script src="/static/libs/pixi/6.5.9/pixi.min.js"></script>
<script src="/static/libs/pixi-tilemap/2.1.3/pixi-tilemap.umd.js"></script>
<!-- 添加备用CDN源 -->
<script>
    // 全局状态变量
    window.PIXI_LOADED = false;
    window.PIXI_TILEMAP_LOADED = false;
    window.PIXI_LOAD_ATTEMPTS = 0;
    window.PIXI_TILEMAP_LOAD_ATTEMPTS = 0;
    window.MAX_LOAD_ATTEMPTS = 3; // 最大尝试次数

    // CDN 源列表
    const PIXI_CDN_SOURCES = [
        // 本地优先（再次兜底，若上面的直链加载失败）
        "/static/libs/pixi/6.5.9/pixi.min.js",
        "https://cdnjs.cloudflare.com/ajax/libs/pixi.js/6.5.9/pixi.min.js",
        "https://cdn.jsdelivr.net/npm/pixi.js@6.5.9/dist/browser/pixi.min.js",
        "https://unpkg.com/pixi.js@6.5.9/dist/browser/pixi.min.js"
    ];
    const PIXI_TILEMAP_CDN_SOURCES = [
        // 本地优先（再次兜底）
        "/static/libs/pixi-tilemap/2.1.3/pixi-tilemap.umd.js",
        "https://cdnjs.cloudflare.com/ajax/libs/pixi-tilemap/2.1.3/pixi-tilemap.umd.js",
        "https://cdn.jsdelivr.net/npm/pixi-tilemap@2.1.3/dist/pixi-tilemap.umd.js" // 将主CDN作为备选之一
    ];

    // 检查Pixi.js是否加载成功
    function checkPixiLoaded() {
        if (typeof PIXI !== 'undefined' && PIXI.Application) {
            if (!window.PIXI_LOADED) { // 避免重复打印日志
                console.log('Pixi.js已成功加载');
                window.PIXI_LOADED = true;
            }
            return true;
        }
        return false;
    }

    // 检查Pixi-tilemap是否加载成功
    function checkPixiTilemapLoaded() {
        // 假设 PIXI.tilemap 在 tilemap 加载后会被定义
        if (typeof PIXI !== 'undefined' && PIXI.tilemap) {
            if (!window.PIXI_TILEMAP_LOADED) { // 避免重复打印日志
                console.log('Pixi-tilemap已成功加载');
                window.PIXI_TILEMAP_LOADED = true;
            }
            return true;
        }
        return false;
    }

    // 通用库加载函数
    function loadLibrary(libraryName, checkLoadedFunc, cdnSources, attemptCounterKey, loadedFlagKey, onFinallyCallback) {
        if (window[loadedFlagKey] || checkLoadedFunc()) { // 如果已加载，则直接调用回调
            if(onFinallyCallback) onFinallyCallback();
            return;
        }

        if (window[attemptCounterKey] >= window.MAX_LOAD_ATTEMPTS) {
            console.error(`${libraryName}加载失败，已达到最大尝试次数`);
            if (libraryName === 'Pixi.js') {
                alert('游戏引擎核心组件加载失败，请检查网络连接或刷新页面重试。');
            } else if (libraryName === 'Pixi-tilemap') {
                alert('游戏地图组件加载失败，请检查网络连接或刷新页面重试。');
            }
            if(onFinallyCallback) onFinallyCallback(); // 即使失败也调用，以便后续逻辑判断
            return;
        }

        window[attemptCounterKey]++;
        console.log(`${libraryName}加载尝试 ${window[attemptCounterKey]}/${window.MAX_LOAD_ATTEMPTS}...`);

        const oldScripts = document.querySelectorAll(`script[data-backup-for="${libraryName}"]`);
        oldScripts.forEach(script => script.parentNode.removeChild(script));

        const currentCdn = cdnSources[(window[attemptCounterKey] - 1) % cdnSources.length];
        if (!currentCdn) { // 以防CDN列表配置错误或尝试次数超出列表
            console.error(`${libraryName} 无可用CDN源进行尝试 ${window[attemptCounterKey]}`);
            if(onFinallyCallback) onFinallyCallback();
            return;
        }
        
        console.log(`尝试从 ${currentCdn} 加载 ${libraryName}`);
        var backupScript = document.createElement('script');
        backupScript.src = currentCdn;
        backupScript.setAttribute('data-backup-for', libraryName);
        backupScript.onload = function() {
            if (checkLoadedFunc()) {
                window[loadedFlagKey] = true;
                console.log(`${libraryName} 从 ${currentCdn} 加载成功`);
            } else {
                // Onload触发但检查失败，这通常不应该发生，但作为健壮性处理
                console.error(`从 ${currentCdn} 加载 ${libraryName} 后检查失败`);
            }
            if(onFinallyCallback) onFinallyCallback();
        };
        backupScript.onerror = function() {
            console.error(`从 ${currentCdn} 加载 ${libraryName} 失败`);
            // 延迟后尝试下一个
            setTimeout(() => loadLibrary(libraryName, checkLoadedFunc, cdnSources, attemptCounterKey, loadedFlagKey, onFinallyCallback), 1000);
        };
        document.head.appendChild(backupScript);
    }

    // 触发最终的 'pixiLoaded' 事件
    function dispatchPixiLoadedEvent() {
        if (window.PIXI_LOADED && window.PIXI_TILEMAP_LOADED) {
            console.log('Pixi.js 和 Pixi-tilemap 均已成功加载，触发 pixiLoaded 事件。');
            document.dispatchEvent(new Event('pixiLoaded'));
        } else {
            console.error('Pixi.js 或 Pixi-tilemap 未能完全加载。pixiLoaded 事件未触发。');
            // 之前的 alert 应该已经通知用户具体哪个库失败了
        }
    }

    // 初始化加载器
    function initializeLoaders() {
        // 首先尝试加载 Pixi.js
        loadLibrary('Pixi.js', checkPixiLoaded, PIXI_CDN_SOURCES, 'PIXI_LOAD_ATTEMPTS', 'PIXI_LOADED', () => {
            // Pixi.js 加载尝试完成后 (无论成功或失败)
            if (window.PIXI_LOADED) {
                // 如果 Pixi.js 成功加载，则尝试加载 Pixi-tilemap
                loadLibrary('Pixi-tilemap', checkPixiTilemapLoaded, PIXI_TILEMAP_CDN_SOURCES, 'PIXI_TILEMAP_LOAD_ATTEMPTS', 'PIXI_TILEMAP_LOADED', () => {
                    // Pixi-tilemap 加载尝试完成后 (无论成功或失败)
                    dispatchPixiLoadedEvent();
                });
            } else {
                // 如果 Pixi.js 加载失败，则无需尝试加载 tilemap，直接尝试分发事件（会失败）
                dispatchPixiLoadedEvent();
            }
        });
    }

    // DOM加载完成后开始初始化
    window.addEventListener('DOMContentLoaded', function() {
        // 延迟一点时间给页面上通过 <script src="..."> 的主CDN一些加载时间
        setTimeout(function() {
            // 先检查一次主CDN是否已成功加载
            const pixiAlreadyLoadedByPrimary = checkPixiLoaded();
            const tilemapAlreadyLoadedByPrimary = checkPixiTilemapLoaded();

            if (pixiAlreadyLoadedByPrimary && tilemapAlreadyLoadedByPrimary) {
                dispatchPixiLoadedEvent(); // 如果都已通过主CDN加载，直接触发事件
            } else {
                initializeLoaders(); //否则启动备用加载逻辑
            }
        }, 1000); 
    });
</script>

<style type="text/css">
:root {
    /* 黑金主题色彩方案 */
    --font-family-ui: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft YaHei', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    --font-family-mono: 'Consolas', 'Monaco', 'Courier New', monospace;

    /* 背景色 - 黑色系 */
    --bg-primary: #0a0a0a;      /* 主背景 - 纯黑 */
    --bg-secondary: #1a1a1a;    /* 次要背景 - 深灰黑 */
    --bg-tertiary: #2a2a2a;     /* 第三背景 - 中灰黑 */
    --bg-backdrop: rgba(0, 0, 0, 0.85); /* 遮罩背景 */
    --bg-hover: #333333;        /* 悬停背景 */

    /* 文字色 - 淡金色系 */
    --text-primary: #f4e4c1;    /* 主文字 - 淡金色 */
    --text-secondary: #d4c4a1;  /* 次要文字 - 暗淡金色 */
    --text-tertiary: #b4a481;   /* 第三文字 - 更暗的金色 */
    --text-inverted: #0a0a0a;   /* 反色文字 */
    --text-on-accent: #0a0a0a;  /* 强调色上的文字 */

    /* 边框色 - 金色系 */
    --border-color: #4a3f2a;        /* 主边框 - 暗金色 */
    --border-color-light: #6a5f3a;  /* 轻边框 - 亮暗金色 */
    --border-color-transparent: rgba(244, 228, 193, 0.2); /* 透明边框 */
    --border-accent: #f4e4c1;       /* 强调边框 - 淡金色 */

    /* 强调色 - 金色调整 */
    --accent-primary: #d4af37;     /* 主强调色 - 金色 */
    --accent-secondary: #b8941f;   /* 次要强调色 - 暗金色 */
    --accent-success: #8fbc3f;     /* 成功 - 橄榄金 */
    --accent-warning: #f4c430;     /* 警告 - 亮金色 */
    --accent-error: #dc143c;       /* 错误 - 深红 */
    --accent-info: #4682b4;        /* 信息 - 钢蓝 */
    --accent-purple: #9370db;      /* 紫色 - 中紫 */
    
    --brand-pixi: #f4e4c1;         /* 品牌色 - 淡金色 */

    /* 圆角 */
    --border-radius-sm: 6px;
    --border-radius-md: 10px;
    --border-radius-lg: 14px;

    /* 阴影 - 金色光晕效果 */
    --shadow-sm: 0 2px 8px rgba(212, 175, 55, 0.1);
    --shadow-md: 0 4px 16px rgba(212, 175, 55, 0.15);
    --shadow-lg: 0 8px 32px rgba(212, 175, 55, 0.2);
    --shadow-glow: 0 0 20px rgba(212, 175, 55, 0.3);

    /* 输入框样式 */
    --input-bg: var(--bg-secondary);
    --input-border: var(--border-color);
    --input-text: var(--text-primary);
    --input-focus-border: var(--accent-primary);
    --input-focus-shadow: 0 0 0 3px rgba(212, 175, 55, 0.2);
}

body {
    font-family: var(--font-family-ui);
    background-color: var(--bg-primary);
    background-image: 
        radial-gradient(circle at 20% 50%, rgba(212, 175, 55, 0.05) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(212, 175, 55, 0.05) 0%, transparent 50%);
    color: var(--text-primary);
    margin: 0;
    padding: 0;
    overflow-x: hidden;
    min-height: 100vh;
}

/* 游戏容器优化 */
#game-container {
    border: none; /* 移除边框 */
    border-radius: 0; /* 改成方形边框 */
    box-shadow: var(--shadow-lg), inset 0 0 50px rgba(212, 175, 55, 0.05);
    margin: 0; /* 移除外边距 */
    width: 100vw; /* 宽度占满视窗 */
    height: 100vh; /* 高度占满视窗 */
    background: rgb(0, 255, 0); /* 改成绿色背景 */
    position: relative;
    overflow: hidden;
}

#game-container canvas {
    border-radius: 0; /* 改成方形边框 */
}

/* 通用按钮样式 - 黑金主题 */
.ui-button {
    padding: 10px 20px;
    border-radius: var(--border-radius-md);
    font-size: 14px;
    font-weight: 600;
    border: 1px solid var(--border-color);
    cursor: pointer;
    font-family: var(--font-family-ui);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    background: linear-gradient(145deg, var(--bg-secondary), var(--bg-primary));
    color: var(--text-primary);
    box-shadow: var(--shadow-sm);
    transition: all 0.3s ease;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
    position: relative;
    overflow: hidden;
}

.ui-button::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: radial-gradient(circle, rgba(212, 175, 55, 0.3), transparent);
    transition: width 0.3s, height 0.3s;
    transform: translate(-50%, -50%);
}

.ui-button:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md), var(--shadow-glow);
    border-color: var(--accent-primary);
    color: var(--accent-primary);
}

.ui-button:hover::before {
    width: 100%;
    height: 100%;
}

.ui-button:active {
    transform: translateY(0);
    box-shadow: var(--shadow-sm);
}

/* 按钮颜色变体 - 黑金主题 */
.ui-button-success { 
    background: linear-gradient(145deg, #1a2f1a, #0a1f0a);
    border-color: var(--accent-success);
    color: var(--accent-success);
}

.ui-button-warning { 
    background: linear-gradient(145deg, #2f2a1a, #1f1a0a);
    border-color: var(--accent-warning);
    color: var(--accent-warning);
}

.ui-button-info { 
    background: linear-gradient(145deg, #1a2a3a, #0a1a2a);
    border-color: var(--accent-info);
    color: var(--accent-info);
}

.ui-button-danger { 
    background: linear-gradient(145deg, #2a1a1a, #1a0a0a);
    border-color: var(--accent-error);
    color: var(--accent-error);
}

.ui-button-secondary { 
    background: linear-gradient(145deg, var(--bg-tertiary), var(--bg-secondary));
    border-color: var(--border-color-light);
    color: var(--text-secondary);
}

/* 输入框样式 - 黑金主题 */
input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    background: linear-gradient(to right, var(--bg-primary), var(--bg-secondary));
    border-radius: var(--border-radius-sm);
    height: 8px;
    cursor: pointer;
    padding: 0;
    border: 1px solid var(--border-color);
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
}

input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: radial-gradient(circle, var(--accent-primary), var(--accent-secondary));
    border: 2px solid var(--bg-primary);
    box-shadow: var(--shadow-md), 0 0 10px rgba(212, 175, 55, 0.5);
    transition: all 0.2s ease;
}

input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.2);
    box-shadow: var(--shadow-lg), 0 0 20px rgba(212, 175, 55, 0.7);
}

input[type="text"].ui-input {
    background: var(--input-bg);
    color: var(--input-text);
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius-sm);
    padding: 8px 12px;
    font-size: 14px;
    font-family: var(--font-family-ui);
    transition: all 0.3s ease;
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
}

input[type="text"].ui-input:focus {
    outline: none;
    border-color: var(--input-focus-border);
    box-shadow: var(--input-focus-shadow), inset 0 2px 4px rgba(0, 0, 0, 0.3);
    color: var(--accent-primary);
}

/* 面板样式 - 黑金主题 */
.ui-panel {
    background: linear-gradient(145deg, var(--bg-secondary), var(--bg-primary));
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius-lg);
    box-shadow: var(--shadow-lg);
    color: var(--text-primary);
    padding: 20px;
    font-family: var(--font-family-ui);
    position: relative;
}

.ui-panel::before {
    content: '';
    position: absolute;
    top: -1px;
    left: -1px;
    right: -1px;
    bottom: -1px;
    background: linear-gradient(45deg, transparent, var(--accent-primary), transparent);
    border-radius: var(--border-radius-lg);
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: -1;
}

.ui-panel:hover::before {
    opacity: 0.1;
}

/* 底部控制面板 - 黑金主题 */
#ui-bottom-panel {
    background: linear-gradient(to top, var(--bg-primary), rgba(26, 26, 26, 0.95)) !important;
    border-top: 2px solid var(--border-color) !important;
    box-shadow: 0 -4px 20px rgba(212, 175, 55, 0.1) !important;
    padding: 15px 25px !important;
    display: flex !important;
    align-items: center !important;
    gap: 20px !important;
    backdrop-filter: blur(10px);
}

/* 控制组样式 */
.control-group {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 5px 10px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: var(--border-radius-md);
    border: 1px solid rgba(212, 175, 55, 0.1);
}

.control-label {
    font-size: 13px;
    color: var(--text-secondary);
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.control-value {
    font-size: 14px;
    color: var(--accent-primary);
    min-width: 40px;
    text-align: right;
    font-weight: 600;
    text-shadow: 0 0 5px rgba(212, 175, 55, 0.5);
}

/* 时间显示 - 黑金主题 */
.ui-bottom-panel-right {
    margin-left: auto;
    font-size: 16px;
    font-weight: 500;
    color: var(--text-secondary);
    display: flex;
    align-items: center;
    gap: 10px;
}

.ui-bottom-panel-right #time-display {
    color: var(--accent-primary);
    font-weight: 700;
    font-size: 18px;
    text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
    letter-spacing: 1px;
}

/* 浮动窗口 - 黑金主题 */
.floating-window {
    position: absolute;
    background: linear-gradient(145deg, rgba(26, 26, 26, 0.98), rgba(10, 10, 10, 0.98));
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius-lg);
    box-shadow: var(--shadow-lg), 0 0 30px rgba(212, 175, 55, 0.1);
    padding: 0;
    z-index: 10000;
    user-select: none;
    min-width: 280px;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
    color: var(--text-primary);
    font-family: var(--font-family-ui);
}

.floating-window:hover {
    box-shadow: var(--shadow-lg), 0 0 40px rgba(212, 175, 55, 0.2);
    border-color: var(--border-color-light);
}

.window-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 16px;
    border-bottom: 1px solid var(--border-color);
    cursor: move;
    background: rgba(212, 175, 55, 0.05);
}

.window-title {
    font-size: 15px;
    font-weight: 700;
    color: var(--accent-primary);
    text-shadow: 0 0 5px rgba(212, 175, 55, 0.5);
    letter-spacing: 0.5px;
}

.window-close {
    background: none;
    border: none;
    color: var(--text-tertiary);
    font-size: 22px;
    font-weight: bold;
    cursor: pointer;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s ease;
}

.window-close:hover {
    background-color: var(--accent-error);
    color: var(--text-on-accent);
    transform: rotate(90deg);
}

.window-content {
    padding: 16px;
    color: var(--text-primary);
    font-family: var(--font-family-mono);
}

.floating-window.settings-panel .window-content {
    font-family: var(--font-family-ui);
}

/* 时钟显示 - 黑金主题 */
.clock-display {
    font-size: 20px;
    text-align: center;
    margin: 8px 0;
    color: var(--accent-primary);
    text-shadow: 0 0 15px rgba(212, 175, 55, 0.7);
    font-weight: 700;
    letter-spacing: 2px;
}

.clock-date {
    font-size: 14px;
    text-align: center;
    margin-bottom: 8px;
    color: var(--text-secondary);
    letter-spacing: 0.5px;
}

/* 对话框样式 - 黑金主题 */
#ui-dialog-panel {
    background: linear-gradient(to top, var(--bg-primary), rgba(26, 26, 26, 0.95)) !important;
    border-top: 2px solid var(--border-color) !important;
    box-shadow: 0 -4px 20px rgba(212, 175, 55, 0.1) !important;
    color: var(--text-primary) !important;
    font-family: var(--font-family-ui);
    padding: 20px !important;
    border-radius: var(--border-radius-lg) var(--border-radius-lg) 0 0;
    max-height: 400px;
    overflow-y: auto;
}

/* 聊天消息样式 - 黑金主题 */
.chat-message {
    margin: 15px 0;
    animation: fadeIn 0.5s ease;
    position: relative;
    width: 100%;
}

.chat-avatar {
    border-radius: 50% !important;
    box-shadow: 0 2px 8px rgba(212, 175, 55, 0.2);
    border: 2px solid var(--border-color);
}

.chat-name {
    font-size: 11px;
    color: var(--text-tertiary);
    margin-top: 4px;
    text-align: center;
    max-width: 50px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    font-weight: 500;
}

/* 左侧消息气泡 - 黑金主题 */
.chat-message:not([style*="flex-direction: row-reverse"]) .chat-bubble {
    background: linear-gradient(145deg, var(--bg-secondary), var(--bg-tertiary));
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    border-radius: 16px;
    border-top-left-radius: 4px;
    margin-right: 10px;
    box-shadow: var(--shadow-sm);
    display: inline-block;
    max-width: calc(100% - 70px);
    min-width: 50px;
    word-wrap: break-word;
    white-space: pre-wrap;
    box-sizing: border-box;
}

/* 右侧消息气泡 - 黑金主题 */
.chat-message[style*="flex-direction: row-reverse"] .chat-bubble {
    background: linear-gradient(145deg, rgba(212, 175, 55, 0.2), rgba(212, 175, 55, 0.1));
    color: var(--text-primary);
    border: 1px solid var(--accent-primary);
    border-radius: 16px;
    border-top-right-radius: 4px;
    margin-left: 10px;
    box-shadow: var(--shadow-sm), 0 0 10px rgba(212, 175, 55, 0.1);
    display: inline-block;
    max-width: calc(100% - 70px);
    min-width: 50px;
    word-wrap: break-word;
    white-space: pre-wrap;
    box-sizing: border-box;
}

/* 气泡内容样式 */
.chat-bubble {
    padding: 12px 16px;
    word-wrap: break-word;
    text-align: left;
    position: relative;
    overflow: hidden;
}

.chat-bubble::before {
    content: '';
    position: absolute;
    top: -50%;
    right: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(212, 175, 55, 0.1), transparent);
    opacity: 0;
    transition: opacity 0.3s ease;
}

.chat-bubble:hover::before {
    opacity: 1;
}

/* 聊天文本样式 */
.chat-text {
    line-height: 1.6;
    font-size: 14px;
    letter-spacing: 0.3px;
}

/* 系统消息样式 - 黑金主题 */
.system-message {
    text-align: center;
    margin: 10px auto;
    padding: 8px 16px;
    background: linear-gradient(145deg, rgba(212, 175, 55, 0.1), rgba(212, 175, 55, 0.05));
    border-radius: 20px;
    color: var(--text-secondary);
    font-size: 13px;
    max-width: 80%;
    border: 1px solid rgba(212, 175, 55, 0.2);
    font-weight: 500;
}

/* 聊天中的地点信息 - 黑金主题 */
.chat-message[style*="justify-content: center"] {
    background: linear-gradient(145deg, rgba(212, 175, 55, 0.15), rgba(212, 175, 55, 0.08)) !important;
    color: var(--text-primary) !important;
    font-weight: 600 !important;
    border-radius: 20px !important;
    padding: 10px 20px !important;
    font-size: 13px !important;
    max-width: 85% !important;
    margin: 15px auto !important;
    box-shadow: var(--shadow-sm) !important;
    border: 1px solid rgba(212, 175, 55, 0.3) !important;
    text-align: center !important;
}

/* 消息时间戳样式 - 黑金主题 */
.message-time {
    font-size: 11px !important;
    color: var(--text-tertiary) !important;
    margin-top: 4px !important;
    user-select: none !important;
    opacity: 0.8;
}

/* 滚动条样式 - 黑金主题 */
::-webkit-scrollbar {
    width: 10px;
    height: 10px;
}

::-webkit-scrollbar-track {
    background: var(--bg-primary);
    border-radius: 5px;
}

::-webkit-scrollbar-thumb {
    background: linear-gradient(145deg, var(--border-color), var(--border-color-light));
    border-radius: 5px;
    border: 1px solid var(--bg-primary);
}

::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(145deg, var(--accent-secondary), var(--accent-primary));
}

/* 系统消息弹窗 - 黑金主题 */
.system-message-popup {
    background: linear-gradient(145deg, rgba(26, 26, 26, 0.98), rgba(10, 10, 10, 0.98)) !important;
    border: 1px solid var(--border-color) !important;
    color: var(--text-primary) !important;
    box-shadow: var(--shadow-lg), 0 0 20px rgba(212, 175, 55, 0.2) !important;
}

/* 日期分隔线样式 - 黑金主题 */
.date-separator {
    position: relative;
    text-align: center;
    margin: 25px 0;
    color: var(--text-tertiary);
    font-size: 12px;
}

.date-separator::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(to right, transparent, var(--border-color), transparent);
}

.date-separator span {
    background: var(--bg-primary);
    padding: 0 15px;
    position: relative;
    font-weight: 600;
    letter-spacing: 0.5px;
}

/* 动画优化 */
@keyframes fadeIn {
    from { 
        opacity: 0; 
        transform: translateY(10px);
    }
    to { 
        opacity: 1; 
        transform: translateY(0);
    }
}

@keyframes fadeOut {
    from { 
        opacity: 1; 
        transform: translateY(0);
    }
    to { 
        opacity: 0; 
        transform: translateY(10px);
    }
}

/* 响应式设计 */
@media (max-width: 768px) {
    .ui-button {
        padding: 8px 16px;
        font-size: 13px;
    }
    
    .control-group {
        gap: 8px;
        padding: 4px 8px;
    }
    
    #ui-bottom-panel {
        padding: 10px 15px !important;
        gap: 10px !important;
    }
    
    .floating-window {
        min-width: 240px;
    }
}

/* 加载动画 - 黑金主题 */
@keyframes goldPulse {
    0% { box-shadow: 0 0 10px rgba(212, 175, 55, 0.5); }
    50% { box-shadow: 0 0 30px rgba(212, 175, 55, 0.8); }
    100% { box-shadow: 0 0 10px rgba(212, 175, 55, 0.5); }
}

/* 特殊效果类 */
.gold-glow {
    animation: goldPulse 2s infinite;
}

/* 优化按钮激活状态 */
.ui-button.active {
    background: linear-gradient(145deg, var(--accent-secondary), var(--accent-primary));
    color: var(--bg-primary);
    border-color: var(--accent-primary);
    box-shadow: var(--shadow-md), inset 0 0 10px rgba(212, 175, 55, 0.3);
}

/* 优化设置面板样式 */
.settings-panel {
    min-width: 380px;
}

.settings-panel .window-content > div {
    margin-bottom: 25px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: var(--border-radius-md);
    border: 1px solid rgba(212, 175, 55, 0.1);
}

.settings-panel .window-content > div:last-child {
    margin-bottom: 0;
}

/* 控制标题样式 */
.settings-panel .window-content > div > div:first-child {
    font-size: 16px !important;
    font-weight: 700 !important;
    margin-bottom: 15px !important;
    padding-bottom: 10px !important;
    border-bottom: 2px solid var(--border-color) !important;
    color: var(--accent-primary) !important;
    text-shadow: 0 0 5px rgba(212, 175, 55, 0.5);
}

/* 角色信息面板样式 */
.character-info-panel {
    position: relative;
    overflow: hidden;
}

.character-info-panel::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    background: linear-gradient(45deg, transparent, var(--accent-primary), transparent);
    border-radius: var(--border-radius-lg);
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: -1;
}

.character-info-panel:hover::before {
    opacity: 0.1;
}

/* 角色卡片悬停效果 */
.character-card {
    position: relative;
    overflow: hidden;
}

.character-card:hover {
    transform: translateY(-2px) !important;
    box-shadow: 0 4px 16px rgba(212, 175, 55, 0.2) !important;
    border-color: var(--border-color-light) !important;
}

.character-card:hover img {
    border-color: var(--accent-primary) !important;
    box-shadow: 0 0 8px rgba(212, 175, 55, 0.4) !important;
}

.character-card:hover div {
    color: var(--accent-primary) !important;
}

.character-card::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: radial-gradient(circle, rgba(212, 175, 55, 0.1), transparent);
    transition: width 0.3s, height 0.3s;
    transform: translate(-50%, -50%);
    z-index: 0;
}

.character-card:hover::before {
    width: 100%;
    height: 100%;
}

.character-card > a {
    position: relative;
    z-index: 1;
}
</style>

<script type="text/javascript">
    // 从Flask上下文初始化变量
    var step = {{ step|tojson }};                          
    var step_size = {{ sec_per_step|tojson }} * 1000;     
    step_size = step_size / 1; // 恢复原始时间流速，不再减半
    var zoom = {{ zoom|tojson }};  // 游戏缩放
    var global_time_speed = 1; // 时间流逝速度
    var simulation_name = {{ simulation_name|tojson }}; // 获取模拟名称
    // 添加气泡控制全局变量
    var bubbleScale = 1.0;  // 气泡大小比例
    var globalShowDialogBubbles = false;  // 全局对话气泡显示状态控制 - 默认隐藏
    var dialogBubbleToggleKey = 'd';  // 对话气泡切换快捷键 - 默认D键
    var isDialogBubbleKeyPressed = false;  // 防止重复触发按键事件
    // 添加消息计数器，用于决定消息显示位置（奇数左边，偶数右边）
    var messageCounter = 0;
    var bubbleVerticalOffset = 70;  // 气泡垂直偏移量
    var bubbleHorizontalOffset = 0;  // 气泡水平偏移量
    // 角色头顶图片相关变量
    var characterImages = {}; // 角色头顶图片资源映射
    var characterHeadImages = {}; // 存储角色头顶显示的图片
    var imageContainer; // 专门用于存放头顶图片的容器
    var imageScale = 0.4; // NPC头上图片显示比例 - 恢复并调整大小 (原值0.3, 目标0.6)
    
    if (zoom <= 0) zoom = document.documentElement.clientWidth / 4400;  

    // 性能模式配置（从localStorage读取）
    var performanceMode = (function() {
        try { return localStorage.getItem('ga_performance_mode') || 'high'; } catch (e) { return 'high'; }
    })();

    function getPerformanceConfig(mode) {
        const dpr = window.devicePixelRatio || 1;
        const SAFE_SCALE_MODES = (typeof PIXI !== 'undefined' && PIXI.SCALE_MODES) ? PIXI.SCALE_MODES : { LINEAR: 'linear', NEAREST: 'nearest' };
        const presets = {
            high: { resolution: Math.min(dpr, 2), autoDensity: true, antialias: true, powerPreference: 'high-performance', preserveDrawingBuffer: true, scaleMode: SAFE_SCALE_MODES.LINEAR, roundPixels: true, willReadFrequently: true },
            balanced: { resolution: 1, autoDensity: true, antialias: true, powerPreference: 'high-performance', preserveDrawingBuffer: false, scaleMode: SAFE_SCALE_MODES.LINEAR, roundPixels: true, willReadFrequently: false },
            low: { resolution: 0.75, autoDensity: true, antialias: false, powerPreference: 'low-power', preserveDrawingBuffer: false, scaleMode: SAFE_SCALE_MODES.NEAREST, roundPixels: true, willReadFrequently: false },
            ultra: { resolution: 0.5, autoDensity: true, antialias: false, powerPreference: 'low-power', preserveDrawingBuffer: false, scaleMode: SAFE_SCALE_MODES.NEAREST, roundPixels: true, willReadFrequently: false }
        };
        return presets[mode] || presets.balanced;
    }

    // 设置PixiJS全局渲染质量 - 添加安全检查
    function setupPixiSettings() {
        if (typeof PIXI !== 'undefined' && PIXI.settings && PIXI.SCALE_MODES) {
            const perf = getPerformanceConfig(performanceMode);
            PIXI.settings.SCALE_MODE = perf.scaleMode;
            PIXI.settings.ROUND_PIXELS = perf.roundPixels;
            console.log("PIXI设置成功应用");
            return true;
        } else {
            console.warn("PIXI未正确加载，无法设置渲染质量");
            return false;
        }
    }
    
    // 创建一个等待PIXI加载的函数
    function waitForPixi(callback) {
        if (window.PIXI_LOADED || setupPixiSettings()) {
            callback();
        } else {
            console.log("等待PIXI加载...");
            document.addEventListener('pixiLoaded', callback);
        }
    }
    
    // 游戏基础设置
    var tile_width = 32;                                  
    var movement_speed = {{ play_speed|tojson }};         
    movement_speed = movement_speed * 4; // 将NPC移动速度提高到原始值的4倍
    var execute_count_max = tile_width / movement_speed;   
    execute_count_max = Math.max(1, Math.round(execute_count_max / 2));
    execute_count_max = execute_count_max * 1; // 缩短执行时间使动画更流畅
    var execute_count = execute_count_max;                
    var all_movement = {{ all_movement|tojson }};         

    // 对话历史记录
    var dialogHistory = {};
    // 上一个发言者，用于判断连续的消息是否来自同一人
    var lastSpeaker = null;
    
    // 初始检查对话数据
    function checkInitialConversationData() {
        if (!all_movement || !all_movement["conversation"]) {
            console.warn("对话数据不存在或为空");
            return;
        }
        
        const conversationKeys = Object.keys(all_movement["conversation"]);
        if (conversationKeys.length > 0) {
            const firstKey = conversationKeys[0];
            const firstConversation = all_movement["conversation"][firstKey];
            
            if (typeof firstConversation === 'object') {
                const personaNames = Object.keys(firstConversation).filter(key => key !== 'emoji');
            }
        }
    }
    
    // 在页面加载完成后检查对话数据
    document.addEventListener('DOMContentLoaded', function() {
        // 初始化UI元素
        initializeUI();
        
        // 添加初始对话数据检查
        setTimeout(checkInitialConversationData, 1000);
        
        // 添加微信风格的CSS
        addWeChatStyleCSS();
        
        // 设置自动移除介绍信息的定时器
        setTimeout(function() {
            console.log("开始移除介绍信息...");
            const introMessages = document.querySelectorAll('.intro-message');
            console.log(`找到 ${introMessages.length} 条标记为intro-message的介绍信息`);
            
            // 直接处理已知的NPC介绍对话（通过内容匹配）
            const allMessages = document.querySelectorAll('.chat-message');
            let npcIntroCount = 0;
            
            allMessages.forEach(msg => {
                const textContent = msg.textContent || '';
                if (
                    (textContent.includes('您好！我是本系统的主要角色之一') || 
                     textContent.includes('点击顶部的角色头像') || 
                     textContent.includes('下方控制栏的按钮') ||
                     /^[^\w\s].*观察.*对话/.test(textContent) ||
                     /^[^\w\s].*切换视角/.test(textContent) ||
                     /^[^\w\s].*控制栏/.test(textContent)
                    ) && !msg.classList.contains('intro-message')
                ) {
                    console.log(`找到NPC介绍对话: ${textContent.substring(0, 30)}...`);
                    msg.classList.add('intro-message');
                    npcIntroCount++;
                }
            });
            
            const allIntroMessages = document.querySelectorAll('.intro-message');
            allIntroMessages.forEach(message => {
                message.classList.add('fading');
                setTimeout(() => {
                    if (message.parentNode) {
                        message.parentNode.removeChild(message);
                    }
                }, 500);
            });
        }, 60000);
        
        // 添加可拖动窗口的样式
        const dragWindowStyle = document.createElement('style');
        dragWindowStyle.textContent = `
            .floating-window {
                position: absolute;
                background-color: rgba(35, 39, 42, 0.95);
                border: 1px solid #4f545c;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                padding: 8px;
                z-index: 10000;
                user-select: none;
                min-width: 200px;
                transition: box-shadow 0.3s;
                backdrop-filter: blur(5px);
                color: #e0e0e0;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            }
            
            .floating-window:hover {
                box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            }
            
            .window-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 4px;
                padding-bottom: 4px;
                border-bottom: 1px solid #4f545c;
                cursor: move;
            }
            
            .window-title {
                font-size: 13px;
                font-weight: bold;
                color: #61dafb;
            }
            
            .window-close {
                background: none;
                border: none;
                color: #e06c75;
                font-size: 16px;
                cursor: pointer;
                width: 20px;
                height: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 50%;
            }
            
            .window-close:hover {
                background-color: rgba(224, 108, 117, 0.2);
            }
            
            .window-content {
                color: #ffffff;
                font-family: 'Consolas', 'Monaco', monospace;
            }
            
            .clock-display {
                font-size: 16px;
                text-align: center;
                margin: 4px 0;
                color: #ffffff;
                text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
            }
            
            .clock-date {
                font-size: 13px;
                text-align: center;
                margin-bottom: 4px;
                color: #ffffff;
            }
        `;
        document.head.appendChild(dragWindowStyle);
        
        // 创建浮动时钟窗口按钮
        createFloatingClockButton();
    });
    
    // 添加消息动画样式
    const style = document.createElement('style');
    style.textContent = `
        @keyframes slideInUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .chat-message {
            animation: slideInUp 0.3s ease-out;
            opacity: 0;
            animation-fill-mode: forwards;
        }
        
        .chat-message.show {
            opacity: 1;
        }
        
        .fading {
            opacity: 0;
            transition: opacity 0.5s ease-out;
        }
    `;
    document.head.appendChild(style);

    // 添加微信风格的CSS
    function addWeChatStyleCSS() {
        const style = document.createElement('style');
        style.textContent = `
            /* 对话框整体样式 */
            #ui-dialog-panel {
                background: rgba(35, 39, 42, 0.95) !important;
                border-top: 1px solid #4f545c !important;
                box-shadow: 0 -2px 10px rgba(0,0,0,0.1) !important;
                color: #e0e0e0 !important;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
                padding: 15px !important;
            }
            
            /* 聊天消息动画 */
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(10px); }
                to { opacity: 1; transform: translateY(0); }
            }
            
            @keyframes fadeOut {
                from { opacity: 1; transform: translateY(0); }
                to { opacity: 0; transform: translateY(10px); }
            }
            
            /* 聊天消息样式 */
            .chat-message {
                margin: 12px 0;
                animation: fadeIn 0.3s ease;
                position: relative;
                width: 100%;
            }
            
            /* 头像样式 */
            .chat-avatar {
                border-radius: 4px !important;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            }
            
            /* 名称标签样式 */
            .chat-name {
                font-size: 10px;
                color: #999;
                margin-top: 2px;
                text-align: center;
                max-width: 40px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
            
            /* 左侧发送方气泡样式 - 主角(蓝色) */
            .chat-message:not([style*="flex-direction: row-reverse"]) .chat-bubble {
                background-color: #3498db;
                color: white;
                border-radius: 12px;
                border-top-left-radius: 0;
                margin-right: 10px;
                box-shadow: 0 1px 2px rgba(0,0,0,0.1);
                display: inline-block;
                max-width: calc(100% - 60px);
                min-width: 40px;
                word-wrap: break-word;
                white-space: pre-wrap;
                box-sizing: border-box;
            }
            
            /* 右侧回复方气泡样式 - NPC(白色) */
            .chat-message[style*="flex-direction: row-reverse"] .chat-bubble {
                background-color: #ffffff;
                color: #000000;
                border-radius: 12px;
                border-top-right-radius: 0;
                margin-left: 10px;
                box-shadow: 0 1px 2px rgba(0,0,0,0.1);
                display: inline-block;
                max-width: calc(100% - 60px);
                min-width: 40px;
                word-wrap: break-word;
                white-space: pre-wrap;
                box-sizing: border-box;
                border: 1px solid rgba(0,0,0,0.05);
            }
            
            /* 气泡内容样式 */
            .chat-bubble {
                padding: 10px 15px;
                word-wrap: break-word;
                text-align: left;
            }
            
            /* 聊天文本样式 */
            .chat-text {
                line-height: 1.4;
                font-size: 15px;
            }
            
            /* 系统消息样式 */
            .system-message {
                text-align: center;
                margin: 5px auto;
                padding: 5px 10px;
                background-color: rgba(0,0,0,0.1);
                border-radius: 15px;
                color: #999;
                font-size: 0.9em;
                max-width: 80%;
            }
            
            /* 系统消息样式 - 聊天中的地点信息等 */
            .chat-message[style*="justify-content: center"] {
                background-color: rgba(230, 230, 230, 0.8) !important;
                color: #000000 !important;
                font-weight: 500 !important;
                border-radius: 15px !important;
                padding: 8px 15px !important;
                font-size: 13px !important;
                max-width: 85% !important;
                margin: 10px auto !important;
                box-shadow: 0 1px 2px rgba(0,0,0,0.05) !important;
                border: 1px solid #ccc !important;
            }
            
            /* 聊天消息时间戳样式 */
            .message-time {
                font-size: 11px !important;
                color: #999999 !important;
                margin-top: 3px !important;
                user-select: none !important;
            }
            
            /* 介绍消息的自动消失类 */
            .intro-message {
                animation: fadeIn 0.3s ease-in-out;
                transition: opacity 0.5s ease-in-out;
            }
            
            .intro-message.fading {
                animation: fadeOut 0.5s ease-in-out;
                opacity: 0 !important;
            }
        `;
        document.head.appendChild(style);
        console.log("已添加微信风格CSS");
    }

    // 初始化UI元素
    function initializeUI() {
        // 查找对话面板元素
        const dialogPanel = document.getElementById('ui-dialog-panel');
        const conversationContent = document.getElementById('conversation-content');
        const defaultDialogContent = document.getElementById('default-dialog-content');
        
        if (!dialogPanel || !conversationContent || !defaultDialogContent) {
            console.error("找不到对话面板元素，正在创建...");
            createDialogElements();
        } else {
            console.log("对话面板元素已找到");
            
            // 确保默认内容可见，对话内容隐藏
            conversationContent.style.display = 'none';
            defaultDialogContent.style.display = 'block';
            
            // 显示欢迎消息
            showWelcomeMessages(conversationContent);
        }
    }
    
    // 创建对话面板元素（如果不存在）
    function createDialogElements() {
        const uiDialogPanel = document.getElementById('ui-dialog-panel');
        if (!uiDialogPanel) {
            console.log("创建对话面板元素");
            
            // 创建对话面板
            const dialogPanel = document.createElement('div');
            dialogPanel.id = 'ui-dialog-panel';
            dialogPanel.style.width = '100%';
            dialogPanel.style.minHeight = '150px';
            dialogPanel.style.background = 'linear-gradient(to top, rgba(0,0,0,0.8), rgba(0,0,0,0.6))';
            dialogPanel.style.borderTop = '2px solid #3498db';
            dialogPanel.style.color = 'white';
            dialogPanel.style.padding = '10px 15px';
            dialogPanel.style.marginTop = '20px';
            dialogPanel.style.overflowY = 'auto';
            
            // 创建对话内容区域
            const conversationContent = document.createElement('div');
            conversationContent.id = 'conversation-content';
            conversationContent.style.display = 'none';
            conversationContent.style.flexDirection = 'column';
            conversationContent.style.gap = '10px';
            
            // 创建默认对话内容
            const defaultDialogContent = document.createElement('div');
            defaultDialogContent.id = 'default-dialog-content';
            defaultDialogContent.style.textAlign = 'center';
            defaultDialogContent.style.padding = '20px';
            defaultDialogContent.innerHTML = `
                <p>欢迎来到角色互动模拟世界！</p>
                <p>当角色开始对话时，对话内容将显示在这里。</p>
                <p>您可以通过时间轴来查看角色之间的互动情况。</p>
            `;
            
            // 添加到页面
            dialogPanel.appendChild(conversationContent);
            dialogPanel.appendChild(defaultDialogContent);
            
            // 查找游戏容器，在其后插入对话面板
            const gameContainer = document.getElementById('game-container');
            if (gameContainer && gameContainer.parentNode) {
                gameContainer.parentNode.insertBefore(dialogPanel, gameContainer.nextSibling);
                console.log("对话面板已添加到页面");
                
                // 显示欢迎消息
                showWelcomeMessages(conversationContent);
            } else {
                console.error("无法找到游戏容器，对话面板未添加到页面");
                // 尝试添加到body
                document.body.appendChild(dialogPanel);
            }
        }
    }

    // 时间显示相关设置
    var datetime_options = {                              
        weekday: "long",                                  
        year: "numeric",                                  
        month: "long",                                    
        day: "numeric"                                    
    };
    var start_datetime = new Date(Date.parse({{ start_datetime|tojson }}));  

    // 角色相关变量
    var persona_names = {{ persona_init_pos|tojson }};    
    var spawn_tile_loc = {};                              
    for (var key in persona_names) {                      
        spawn_tile_loc[key] = persona_names[key];         
    }

    var personas = {};                                    
    var pronunciatios = {};                               
    let anims_direction;                                  
    let pre_anims_direction;                              
    let pre_anims_direction_dict = {};                    
    let movement_target = {};                             
    let finished = false;                                 
    let paused = false;                                   
    let lastPlayerDirection = 'down';
    let keyboard = {};
    let player;
    let mapContainer;
    let uiContainer;
    let currentTimeText = null;
    let conversationText;
    let buttonPlay, buttonPause, buttonShowConversation, buttonHideConversation, buttonShowCollision, buttonHideCollision, buttonClearConversation;
    let app = null;
    
    // 添加全局变量，用于跟踪当前锁定的NPC
    let currentLockedCharacter = null;
    let isCharacterLocked = false;

    let floatingClockWindow = null;
    
    // 全局变量，用于存储对话和动作气泡的内容
    let dialogBubbles = {};
    let actionBubbles = {};
    let bubbleTimers = {}; // 存储气泡的定时器
    let typingEffects = {}; // 存储打字效果的状态
    let dialogQueues = {}; // 存储每个NPC的对话队列
    let currentDialogueGroup = []; // 存储当前正在显示的对话组
    let isDialogueGroupPlaying = false; // 是否正在播放对话组
    let dialogueGroupTimer = null; // 对话组计时器
    
    // 添加全局变量
    let globalShowCollisionBoxes = false; // 碰撞框的全局显示状态，默认为隐藏
    
    // 等待DOM加载完成
    document.addEventListener('DOMContentLoaded', function() {
        // 创建游戏容器
        const gameContainer = document.getElementById('game-container');
        if (!gameContainer) {
            console.error("找不到game-container元素");
            return;
        }

        // 获取已经在HTML中定义的UI元素
        const uiBottomPanel = document.getElementById('ui-bottom-panel');
        const uiDialogPanel = document.getElementById('ui-dialog-panel');
        
        if (!uiBottomPanel || !uiDialogPanel) {
            console.error("找不到UI容器元素");
            return;
        }

        // 设置游戏容器样式 - 黑金主题优化
        gameContainer.style.position = 'relative'; // 设置相对定位，以便子元素绝对定位
        gameContainer.style.width = '100%'; // 宽度占满父元素
        gameContainer.style.minHeight = '600px'; // 增加最小高度，确保内容可见
        // gameContainer.style.background = 'linear-gradient(145deg, #0a0a0a, #1a1a1a)'; // 移除背景，让视频背景可见
        gameContainer.style.borderRadius = '14px'; // 圆角边框
        gameContainer.style.overflow = 'hidden'; // 隐藏溢出内容，确保视频在容器内
        gameContainer.style.zIndex = '1'; // 确保游戏容器在视频上方，但低于其他UI元素

        // 获取视频元素并设置样式
        const backgroundVideo = document.getElementById('background-video'); // 获取视频元素
        if (backgroundVideo) { // 如果视频元素存在
            backgroundVideo.style.position = 'absolute'; // 绝对定位，相对于game-container
            backgroundVideo.style.top = '0'; // 顶部对齐
            backgroundVideo.style.left = '0'; // 左部对齐
            backgroundVideo.style.width = '100%'; // 宽度占满game-container
            backgroundVideo.style.height = '100%'; // 高度占满game-container
            backgroundVideo.style.objectFit = 'cover'; // 视频内容覆盖整个区域，可能会裁剪
            backgroundVideo.style.zIndex = '0'; // 将视频置于最底层
            backgroundVideo.style.transform = 'scale(1)'; // 恢复原始大小
        }
        
        // 创建"无对话时显示的默认内容"
        const defaultDialogContent = document.createElement('div');
        defaultDialogContent.id = 'default-dialog-content';
        defaultDialogContent.style.textAlign = 'center';
        defaultDialogContent.style.padding = '30px';
        defaultDialogContent.style.color = '#b4a481';
        defaultDialogContent.style.fontSize = '16px';
        defaultDialogContent.style.fontWeight = '500';
        defaultDialogContent.innerHTML = '✨ 当前没有对话内容 ✨';
        uiDialogPanel.appendChild(defaultDialogContent);

        // 创建对话内容容器
        const dialogContent = document.createElement('div');
        dialogContent.id = 'conversation-content';
        dialogContent.style.display = 'flex';
        dialogContent.style.flexDirection = 'column';
        dialogContent.style.gap = '10px';
        uiDialogPanel.appendChild(dialogContent);
        
        // 初始化显示一些模拟对话
        showWelcomeMessages(dialogContent);

        // 等待PIXI加载完成后再初始化游戏
        waitForPixi(function() {
            console.log("PIXI已加载，开始初始化游戏视图...");
            try {
                // 创建PixiJS应用
                const gameContainer = document.getElementById('game-container');
                const perf = getPerformanceConfig(performanceMode);
                app = new PIXI.Application({
                    width: gameContainer.clientWidth, // 设置Canvas宽度为游戏容器的宽度
                    height: gameContainer.clientHeight, // 设置Canvas高度为游戏容器的高度
                    // backgroundColor: 0x00FF00, // 移除背景颜色，或者设置为透明
                    transparent: true, // 设置Canvas背景为透明
                    resolution: perf.resolution,
                    autoDensity: perf.autoDensity,
                    antialias: perf.antialias,
                    powerPreference: perf.powerPreference,
                    preserveDrawingBuffer: perf.preserveDrawingBuffer,
                });

                // 设置渲染质量（按性能模式）
                PIXI.settings.SCALE_MODE = perf.scaleMode;
                PIXI.settings.ROUND_PIXELS = perf.roundPixels;
                if (perf.willReadFrequently) {
                    app.view.getContext('2d', { willReadFrequently: true });
                }

                // 不限制目标帧率

                // 设置canvas属性
                app.renderer.view.style.position = 'absolute'; // 改为绝对定位，以便于视频背景叠放
                app.renderer.view.style.top = '0'; // Canvas顶部对齐
                app.renderer.view.style.left = '0'; // Canvas左部对齐
                app.renderer.view.style.display = 'block'; // 设置为块级元素
                app.renderer.view.style.margin = '0 auto'; // 水平居中（在绝对定位下可能需要调整）
                app.renderer.view.style.width = '100%'; // Canvas宽度占满父元素
                app.renderer.view.style.height = '100%'; // Canvas高度占满父元素
                app.renderer.view.style.zIndex = '1'; // 确保Canvas在视频背景之上
                
                // 立即设置willReadFrequently属性（按性能模式）
                if (perf.willReadFrequently) {
                    app.view.willReadFrequently = true;
                    const context = app.view.getContext('webgl') || app.view.getContext('2d');
                    if (context && context.willReadFrequently !== undefined) {
                        context.willReadFrequently = true;
                    }
                }
                
                // 添加到容器
                gameContainer.appendChild(app.view);
                
                // 在canvas添加到DOM后再次确保willReadFrequently属性（按性能模式）
                if (perf.willReadFrequently) {
                    setTimeout(() => {
                        setCanvasWillReadFrequently();
                    }, 100);
                }
                
                // 优化缩放质量
                app.stage.scale.set(zoom);
                
                // 添加缩放控制功能
                setupZoomControls();
                
                // 监听窗口大小变化，调整画布大小
                window.addEventListener('resize', handleResize);
                
                // 监听全屏状态变化
                document.addEventListener('fullscreenchange', function() {
                    // 延迟处理，确保全屏状态已经完全改变
                    setTimeout(() => {
                        handleResize();
                    }, 100);
                });
                
                // 兼容其他浏览器的全屏事件
                document.addEventListener('webkitfullscreenchange', function() {
                    setTimeout(() => {
                        handleResize();
                    }, 100);
                });
                
                document.addEventListener('mozfullscreenchange', function() {
                    setTimeout(() => {
                        handleResize();
                    }, 100);
                });
                
                document.addEventListener('MSFullscreenChange', function() {
                    setTimeout(() => {
                        handleResize();
                    }, 100);
                });
                
                // 初始化屏幕比例
                setTimeout(() => {
                    handleResize();
                }, 500);
                
                // 开始加载资源
                loadResources();
            } catch (error) {
                console.error("创建PIXI应用时出错:", error);
                alert("游戏初始化失败，请刷新页面重试。错误: " + error.message);
            }
        });
    });

    // 添加缩放控制功能
    function setupZoomControls() {
        try {
            // 不再创建游戏内UI控件，而是在底部控制栏中添加
            console.log("缩放控制已移至底部控制栏");
        } catch (error) {
            console.error("设置缩放控制时出错:", error);
        }
    }
    
    // 设置屏幕比例控制 - 修改这个函数来移除游戏内的控制UI
    function setupAspectRatioControls() {
        try {
            // 不再创建游戏内UI控件，而是在底部控制栏中添加
            console.log("屏幕比例控制已移至底部控制栏");
        } catch (error) {
            console.error("设置屏幕比例控制时出错:", error);
        }
    }
    
    // 调整游戏画面比例
    function adjustGameAspectRatio(ratio) {
        try {
            const gameContainer = document.getElementById('game-container');
            if (!gameContainer || !app) return;
            
            // 保存当前视图中心
            const centerX = app.stage.pivot.x;
            const centerY = app.stage.pivot.y;
            
            // 获取可用宽度
            const availableWidth = document.documentElement.clientWidth;
            let targetHeight;
            
            if (ratio === 'fullscreen') {
                // 全屏模式
                if (!document.fullscreenElement) {
                    // 进入全屏
                    if (app.view.requestFullscreen) {
                        app.view.requestFullscreen().then(() => {
                            // 全屏成功后调整尺寸
                            setTimeout(() => {
                                const screenWidth = window.innerWidth;
                                const screenHeight = window.innerHeight;
                                app.renderer.resize(screenWidth, screenHeight);
                                gameContainer.style.height = `${screenHeight}px`;
                                
                                // 恢复视图中心
                                app.stage.position.set(app.screen.width / 2, app.screen.height / 2);
                                app.stage.pivot.set(centerX, centerY);
                                
                                // 强制重新渲染
                                app.renderer.render(app.stage);
                                
                                console.log(`已调整游戏画面比例为全屏模式`);
                            }, 100);
                        }).catch(err => {
                            console.error('进入全屏失败:', err);
                            // 全屏失败，使用自适应模式
                            adjustGameAspectRatio('auto');
                        });
                    }
                } else {
                    // 已经在全屏模式，直接调整尺寸
                    const screenWidth = window.innerWidth;
                    const screenHeight = window.innerHeight;
                    app.renderer.resize(screenWidth, screenHeight);
                    gameContainer.style.height = `${screenHeight}px`;
                    
                    // 恢复视图中心
                    app.stage.position.set(app.screen.width / 2, app.screen.height / 2);
                    app.stage.pivot.set(centerX, centerY);
                    
                    // 强制重新渲染
                    app.renderer.render(app.stage);
                    
                    console.log(`已调整游戏画面比例为全屏模式`);
                }
                
                // 保存当前设置到localStorage
                try {
                    //确保当 ratio 为 'fullscreen' 时，正确保存字符串 'fullscreen'
                    localStorage.setItem('gameAspectRatio', String(ratio)); 
                } catch (e) {
                    console.warn('无法保存画面比例设置:', e);
                }
                return;
            } else {
                // 非全屏模式，如果当前在全屏状态则退出全屏
                if (document.fullscreenElement) {
                    if (document.exitFullscreen) {
                        document.exitFullscreen().then(() => {
                            // 退出全屏后延迟处理，确保尺寸已更新
                            setTimeout(() => {
                                handleResize();
                            }, 100);
                        }).catch(err => {
                            console.error('退出全屏失败:', err);
                            // 继续处理非全屏模式
                            applyNonFullscreenRatio();
                        });
                    }
                    return; // 退出函数，等待全屏退出后的回调处理
                }
                
                // 处理非全屏模式
                applyNonFullscreenRatio();
            }
            
            // 内部函数：应用非全屏比例
            function applyNonFullscreenRatio() {
                if (ratio === 'auto') {
                    // 自适应模式
                    targetHeight = Math.min(document.documentElement.clientHeight * 0.7, 800) + 120;
                } else {
                    // 根据比例计算高度
                    targetHeight = availableWidth / parseFloat(ratio) + 120;
                    // 限制最大高度
                    targetHeight = Math.min(targetHeight, window.innerHeight - 100);
                }
                
                // 应用新尺寸
                app.renderer.resize(availableWidth, targetHeight);
                gameContainer.style.height = `${targetHeight}px`;
                
                // 更新UI位置
                const uiBottomPanel = document.getElementById('ui-bottom-panel');
                if (uiBottomPanel) {
                    uiBottomPanel.style.top = `${targetHeight}px`;
                }
                
                // 恢复视图中心
                app.stage.position.set(app.screen.width / 2, app.screen.height / 2);
                app.stage.pivot.set(centerX, centerY);
                
                // 强制重新渲染
                app.renderer.render(app.stage);
                
                console.log(`已调整游戏画面比例为 ${ratio === 'auto' ? '自适应' : ratio}`);
                
                // 保存当前设置到localStorage
                try {
                    localStorage.setItem('gameAspectRatio', ratio);
                } catch (e) {
                    console.warn('无法保存画面比例设置:', e);
                }
            }
            
            // // 如果不是全屏模式，直接应用非全屏比例
            // // 这段逻辑似乎是多余的，因为 applyNonFullscreenRatio 已经在前面被调用了
            // if (ratio !== 'fullscreen') {
            //     applyNonFullscreenRatio();
            // }
        } catch (error) {
            console.error("调整游戏画面比例时出错:", error);
        }
    }

    // 处理窗口大小变化
    function handleResize() {
        if (app) {
            try {
                // 检查是否处于全屏模式
                const isFullscreen = document.fullscreenElement !== null;
                
                // 获取保存的比例设置
                let savedRatio;
                try {
                    savedRatio = localStorage.getItem('gameAspectRatio');
                    if (savedRatio === 'fullscreen' || savedRatio === 'auto') {
                        // 使用字符串值
                    } else if (savedRatio) {
                        savedRatio = parseFloat(savedRatio);
                    }
                } catch (e) {
                    console.warn('无法获取保存的画面比例设置:', e);
                    savedRatio = 'auto';  // 默认自适应
                }
                
                // 当浏览器进入或退出全屏模式时（例如通过F11或浏览器缩放导致的全屏），
                // 我们调用 adjustGameAspectRatio 来重新计算和应用布局。
                // savedRatio 会从 localStorage 读取，如果它是 'fullscreen'，则游戏会尝试保持全屏。
                // 如果 savedRatio 不是 'fullscreen'（比如 'auto' 或一个数字比例），
                // 即使浏览器进入了全屏，游戏也会根据这个非全屏的 savedRatio 来调整，
                // 这意味着游戏内容区不会填满整个屏幕，除非用户通过游戏内按钮明确设置了全屏。
                adjustGameAspectRatio(savedRatio || 'auto');
                
                // 如果是全屏模式，直接调整到全屏尺寸
                if (isFullscreen) {
                    const screenWidth = window.innerWidth;
                    const screenHeight = window.innerHeight;
                    app.renderer.resize(screenWidth, screenHeight);
                    
                    const gameContainer = document.getElementById('game-container');
                    if (gameContainer) {
                        gameContainer.style.height = `${screenHeight}px`;
                    }
                    
                    // 恢复视图中心
                    app.stage.position.set(app.screen.width / 2, app.screen.height / 2);
                } 
                // 否则应用保存的比例
                else if (savedRatio) {
                    adjustGameAspectRatio(savedRatio);
                } else {
                    // 默认调整
                    adjustGameAspectRatio('auto');
                }
            } catch (error) {
                console.error("窗口大小变化处理时出错:", error);
                
                // 出错时使用默认调整
                try {
                    app.renderer.resize(
                        document.documentElement.clientWidth,
                        Math.min(document.documentElement.clientHeight * 0.7, 800)
                    );
                } catch (e) {
                    console.error("应用默认调整时出错:", e);
                }
            }
        }
    }

    // 应用高质量缩放
    function applyHighQualityZoom(zoomLevel) {
        try {
            // 记录当前视图中心
            const centerX = app.stage.pivot.x;
            const centerY = app.stage.pivot.y;
            
            // 使用整数缩放级别避免模糊
            const roundedZoom = Math.round(zoomLevel * 100) / 100;
            
            // 缩放设置：不在此处修改 renderer.resolution，避免与性能模式冲突
            app.stage.scale.set(roundedZoom);
            
            // 确保sprite使用高质量缩放模式
            if (app && app.stage && app.stage.children) {
                app.stage.children.forEach(container => {
                    if (container && container.children) {
                        container.children.forEach(sprite => {
                            if (sprite && sprite.texture && sprite.texture.baseTexture) {
                                // 按当前全局设置应用缩放模式（随性能模式切换）
                                sprite.texture.baseTexture.scaleMode = PIXI.settings.SCALE_MODE;
                            }
                        });
                    }
                });
            }
            
            // 更新所有对话气泡的缩放，使其大小不受游戏缩放影响
            for (let personaName in pronunciatios) {
                if (pronunciatios[personaName] && pronunciatios[personaName].container) {
                    updateBubblePosition(personaName);
                }
            }
            
            // 强制整个舞台重新渲染
            if (app && app.renderer) {
                app.renderer.render(app.stage);
            }
            
            console.log(`应用高质量缩放: ${roundedZoom}`);
        } catch (error) {
            console.error("应用高质量缩放时出错:", error);
        }
    }
    
    // 设置Canvas willReadFrequently属性
    function setCanvasWillReadFrequently() {
        try {
            // 应用到所有canvas元素
            document.querySelectorAll('canvas').forEach(canvas => {
                const context = canvas.getContext('2d');
                if (context) {
                    context.willReadFrequently = true;
                }
                canvas.willReadFrequently = true;
                console.log("设置canvas willReadFrequently=true");
            });
            
            // 应用到PixiJS的canvas
            if (app && app.view) {
                const context = app.view.getContext('2d');
                if (context) {
                    context.willReadFrequently = true;
                }
                app.view.willReadFrequently = true;
                console.log("设置PixiJS canvas willReadFrequently=true");
            }
        } catch (error) {
            console.error("设置canvas willReadFrequently属性失败:", error);
        }
    }

    // 创建UI文本
    function createText(x, y, text, bgColor = 0xffffcc, emoji = "") {
        const container = new PIXI.Container();
        
        // 使用更醒目的样式
        const style = new PIXI.TextStyle({
            fontFamily: '黑体',
            fontSize: 26,
            fontWeight: 'bold',
            fill: '#FFFFFF',
            stroke: '#000000',
            strokeThickness: 2,
            wordWrap: true,
            wordWrapWidth: 1200/zoom,
            dropShadow: true,
            dropShadowColor: '#000000',
            dropShadowBlur: 4,
            dropShadowDistance: 2
        });
        
        const textSprite = new PIXI.Text(`${emoji} ${text}`, style);
        
        const padding = {x: 20, y: 8};
        const background = new PIXI.Graphics();
        background.beginFill(bgColor);
        background.lineStyle(2, 0x000000, 1);
        background.drawRoundedRect(
            -padding.x, 
            -padding.y, 
            textSprite.width + padding.x * 2, 
            textSprite.height + padding.y * 2,
            12
        );
        background.endFill();
        background.alpha = 0.85;
        
        container.addChild(background);
        container.addChild(textSprite);
        
        container.x = x;
        container.y = y;
        container.zIndex = 10;
        container.interactive = true;
        container.buttonMode = true;
        
        // 添加悬停效果
        container.on('pointerover', function() {
            background.alpha = 1;
            container.scale.set(1.05);
        });
        
        container.on('pointerout', function() {
            background.alpha = 0.85;
            container.scale.set(1);
        });
        
        return container;
    }

    // 加载资源
    function loadResources() {
        console.log("开始加载资源...");
        
        // 添加错误处理
        app.loader.onError.add((error, loader, resource) => {
            console.error("资源加载错误:", error);
            console.error("资源:", resource.url);
            showSystemMessage(`资源加载失败: ${resource.url.split('/').pop()}`);
        });
        
        // 报告进度
        app.loader.onProgress.add((loader, resource) => {
            console.log(`加载进度: ${Math.round(loader.progress)}% - 加载: ${resource.url}`);
            
            // 显示加载进度
            if (Math.round(loader.progress) % 20 === 0) { // 每20%显示一次
                showSystemMessage(`资源加载中: ${Math.round(loader.progress)}%`, 1000);
            }
        });
        
        // 添加特殊断点检测
        app.loader.onComplete.add((loader, resources) => {
            console.log("资源加载完成，检查关键资源是否存在");
            
            // 检查地图资源
            if (!resources.map) {
                console.error("地图资源加载失败，尝试再次加载");
                showSystemMessage("地图资源加载失败，尝试备用方案");
                
                // 尝试直接加载地图JSON
                fetch('static/assets/village/tilemap/tilemap.json')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('网络错误');
                        }
                        return response.json();
                    })
                    .then(data => {
                        console.log("直接获取地图数据成功");
                        resources.map = { data };
                        setupGame(resources);
                    })
                    .catch(error => {
                        console.error("直接获取地图数据失败:", error);
                        setupGame(resources); // 继续使用原有资源
                    });
            }
            
            // 检查玩家纹理
            if (!resources.player_spritesheet) {
                console.error("玩家纹理加载失败");
                showSystemMessage("玩家纹理加载失败，将使用占位符");
            }
            
            // 加载角色图片资源
            loadCharacterImages();
        });
        
        // 加载地图瓦片
        // Dynamically load PNGs found in the tilemap directory
        // Based on the files found in 'generative_agents/frontend/static/assets/village/tilemap/'
        const tilemapPngFiles = ["1.png", "色表.png"]; // Detected PNG files
        tilemapPngFiles.forEach(fileName => {
            // Extract the name without extension to use as a resource key
            // Replace non-alphanumeric characters from filename for a valid key if necessary.
            const resourceKey = "tilemap_" + fileName.substring(0, fileName.lastIndexOf('.')).replace(/[^a-zA-Z0-9_]/g, '_');
            app.loader.add(resourceKey, `static/assets/village/tilemap/${fileName}`);
            console.log(`Loading tilemap: ${`static/assets/village/tilemap/${fileName}`}`);
        });
        
        app.loader.add('map', 'static/assets/village/tilemap/tilemap.json');

        // 加载玩家和NPC的精灵表
        // 首先尝试加载默认玩家角色纹理
        const defaultPlayerTextures = [
            'static/assets/village/agents/实验者/texture.png',
            'static/assets/village/agents/default_player/texture.png',
            'static/assets/village/agents/player/texture.png'
        ];
        
        // 尝试加载第一个可用的默认玩家纹理（如果文件不存在会失败，但不会阻止游戏运行）
        app.loader.add('default_player_spritesheet', defaultPlayerTextures[0]);
        
        // 添加错误处理，确保即使纹理加载失败也能继续
        app.loader.onError.add((error, loader, resource) => {
            console.warn(`资源加载失败: ${resource.url}`, error);
            // 继续加载其他资源
        });
        
        // 加载所有NPC的精灵表
        let npcCount = 0;
        for (let p in persona_names) {
            if (p !== '实验者') {  // 跳过玩家角色
                app.loader.add(`${p}_spritesheet`, `static/assets/village/agents/${p}/texture.png`);
                npcCount++;
            }
        }
        
        console.log(`准备加载 ${npcCount} 个NPC角色纹理`);
        
        // 如果没有任何角色数据，至少确保有默认纹理
        if (Object.keys(persona_names).length === 0) {
            console.warn("没有角色数据，将使用默认设置");
        }

        // 开始加载
        app.loader.load((loader, resources) => {
            console.log("资源加载完成");
            console.log("加载的资源:", Object.keys(resources));
            setupGame(resources);
        });
    }

    // 加载角色头顶图片
    function loadCharacterImages() {
        console.log("开始加载角色头顶图片...");
        
        // 角色文件夹映射关系（文件夹ID到角色名）
        // const folderToPersonaMap = {
        //     'wxr31': '索伦特'
        //     // 可以根据需要添加更多映射
        // };
        
        // 遍历所有角色文件夹
        // for (const [folderId, personaName] of Object.entries(folderToPersonaMap)) {
        Object.keys(persona_names).forEach(personaName => {
            // 跳过玩家角色，如果它也包含在 persona_names 中且有特殊处理
            if (personaName === '实验者') {
                // 如果"实验者"是玩家并且你不想为玩家加载头顶图片，可以在这里跳过
                // return; 
            }

            // 初始化该角色的图片映射
            if (!characterImages[personaName]) {
                characterImages[personaName] = [];
            }
            
            // 构建请求 list_images 的路径
            // folder_param 应该是 "simulation_name/persona_name"
            const folderParam = `${simulation_name}/${personaName}`;

            // 使用fetch获取角色图片列表
            fetch(`/list_images?folder=${encodeURIComponent(folderParam)}`)
                .then(response => {
                    if (!response.ok) {
                        // 如果响应不成功，则抛出错误，由catch块处理
                        throw new Error(`请求图片列表失败: ${response.status} ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(imageFiles => {
                    if (imageFiles.error) {
                        console.error(`获取${personaName}的图片列表时出错: ${imageFiles.error}`);
                        // 可以选择在这里显示一个用户友好的错误消息，或者记录下来
                        // 例如: showSystemMessage(`无法加载角色 ${personaName} 的图片: ${imageFiles.error.substring(0, 50)}...`, 5000);
                        return;
                    }

                    console.log(`加载${personaName}的图片:`, imageFiles);
                    
                    // 预加载所有图片
                    imageFiles.forEach(file => {
                        // 图片路径现在是 "static/generated_images/simulation_name/persona_name/image_file.png"
                        const imagePath = `static/generated_images/${folderParam}/${file}`;
                        const imgTexture = PIXI.Texture.from(imagePath);
                        
                        // 解析文件名中的时间戳
                        // 假设文件名格式为: YYYY-MM-DD_HHMMSS.png
                        const timeMatch = file.match(/(\d{4}-\d{2}-\d{2})_(\d{2})(\d{2})(\d{2})\.png/);
                        if (timeMatch) {
                            const [_, dateStr, hours, minutes, seconds] = timeMatch;
                            const timeStr = `${hours}:${minutes}:${seconds}`;
                            
                            // 创建日期对象
                            const dateObj = new Date(`${dateStr}T${timeStr}`);
                            
                            // 存储图片信息
                            characterImages[personaName].push({
                                texture: imgTexture,
                                timestamp: dateObj,
                                filename: file,
                                path: imagePath
                            });
                            
                            console.log(`加载了${personaName}的图片: ${file}，时间: ${dateObj}`);
                        } else {
                            console.warn(`无法解析文件名中的时间戳: ${file}`);
                        }
                    });
                })
                .catch(error => {
                    console.error(`获取${personaName}图片列表失败:`, error);
                });
        });
    }

    // 存储角色头顶图片精灵的对象
    // 已在全局变量区域声明过var characterHeadImages，所以这里不需要重复声明
    // const characterHeadImages = {};

    // 更新角色头顶图片
    function updateCharacterImage(personaName, currentGameTime) {
        // 检查角色是否有图片资源
        if (!characterImages || !characterImages[personaName] || !characterImages[personaName].length) {
            return;
        }
        
        // 获取角色对象
        const character = personas[personaName];
        if (!character) {
            return;
        }
        
        // 检查是否已经有图片在显示
        if (characterHeadImages[personaName] && 
            characterHeadImages[personaName].container && 
            characterHeadImages[personaName].active) {
            
            // 图片已经在显示，需要更新位置
            const container = characterHeadImages[personaName].container;
            
            // 获取当前游戏缩放比例
            const currentZoom = app.stage.scale.x;
            
            // 更新位置以跟随角色
            container.x = character.x;
            
            // 计算y偏移量，基于缩放级别动态调整，图片y轴缩放
            // 使用双曲线函数计算：当zoom=0.1时y偏移=-800，当zoom=1时y偏移=-200
            // 双曲线算法考虑了缩放比例的非线性变化（0.1→0.2是2倍，而0.2→0.3是1.5倍）
            const minOffset = -800;  // 缩放0.1时的偏移值
            const maxOffset = -200;  // 缩放1时的偏移值
            const minZoom = 0.1;     // 最小缩放级别
            const maxZoom = 1;       // 最大缩放级别
            
            // 确保缩放值在有效范围内
            const safeZoom = Math.max(minZoom, Math.min(maxZoom, currentZoom));
            
            // 使用双曲线函数计算缩放因子，而不是线性插值
            // 公式: (1 - minZoom/zoom) / (1 - minZoom/maxZoom)
            // 这样在小缩放值时变化较大，大缩放值时变化较小
            const zoomFactor = (1 - minZoom/safeZoom) / (1 - minZoom/maxZoom);
            
            // 计算当前缩放下的y偏移值
            const yOffset = minOffset + (maxOffset - minOffset) * zoomFactor;
            
            // 输出调试信息到控制台
            console.log("当前游戏缩放:", currentZoom, "非线性缩放因子:", zoomFactor, "计算的y偏移:", yOffset);
            
            // 应用计算后的偏移值
            container.y = character.y + yOffset - 80; // npc图片显示高度
            
            // [图像缩放设置3] - 在位置更新时保持缩放比例一致
            if (currentZoom > 0) {
                // 使用线性插值来设置图片大小
                // 当zoom=0.1时，使用较大的缩放系数；当zoom=1时，使用较小的缩放系数
                const minImageScale = 1;    // 缩放0.1时的图片缩放系数
                const maxImageScale = 1.5;  // 缩放1时的图片缩放系数
                
                // 计算当前缩放下的图片缩放系数
                const dynamicImageScale = minImageScale + (zoomFactor * (maxImageScale - minImageScale));
                
                // 基础系数 × 动态系数 × 气泡比例
                container.scale.set((1 / currentZoom) * bubbleScale * dynamicImageScale * imageScale);
                
                // 输出调试信息到控制台
                console.log("当前游戏缩放:", currentZoom, 
                            "计算的y偏移:", yOffset, 
                            "图片缩放系数:", dynamicImageScale);
            }
            
            return; // 已有活跃图片，不需要创建新的
        }
        
        // 检查是否已经有待显示的图片（延迟显示中）
        if (characterHeadImages[personaName] && characterHeadImages[personaName].pendingDisplay) {
            return; // 有延迟显示的图片，等待计时器触发
        }
        
        // 寻找匹配当前游戏时间的图片
        // 允许5分钟的时间误差范围
        const TIME_TOLERANCE_MS = 5 * 60 * 1000;
        const currentTimeMS = currentGameTime.getTime();
        
        let matchedImage = null;
        let closestTimeDiff = Infinity;
        
        for (const imgInfo of characterImages[personaName]) {
            const timeDiff = Math.abs(imgInfo.timestamp.getTime() - currentTimeMS);
            
            // 如果在误差范围内，并且是最接近的时间
            if (timeDiff < TIME_TOLERANCE_MS && timeDiff < closestTimeDiff) {
                matchedImage = imgInfo;
                closestTimeDiff = timeDiff;
            }
        }
        
        // 如果找到匹配的图片，则安排延迟显示
        if (matchedImage) {
            // 检查是否已经匹配了相同的图片
            if (characterHeadImages[personaName] && 
                characterHeadImages[personaName].currentImagePath === matchedImage.path) {
                return; // 已经在处理这个图片了，不需要重复操作
            }
            
            // 清除之前的状态（如果有）
            if (characterHeadImages[personaName]) {
                // 如果有正在显示的图片，则移除它
                if (characterHeadImages[personaName].container && 
                    characterHeadImages[personaName].container.parent) {
                    characterHeadImages[personaName].container.parent.removeChild(
                        characterHeadImages[personaName].container
                    );
                }
                
                // 清除定时器
                if (characterHeadImages[personaName].timer) {
                    clearTimeout(characterHeadImages[personaName].timer);
                }
                
                // 清除延迟显示计时器
                if (characterHeadImages[personaName].displayTimer) {
                    clearTimeout(characterHeadImages[personaName].displayTimer);
                }
                
                characterHeadImages[personaName] = null;
            }
            
            // 记录匹配的图片，并设置延迟显示
            characterHeadImages[personaName] = {
                pendingDisplay: true,
                currentImagePath: matchedImage.path,
                matchedImage: matchedImage,
                displayTimer: setTimeout(() => {
                    // 延迟5秒后显示图片
                    displayCharacterImage(personaName, character, matchedImage);
                }, 500) // 延迟5秒显示
            };
            
            console.log(`将在5秒后显示${personaName}在${matchedImage.timestamp}的图片`);
        }
    }
    
    // 显示角色头顶图片的函数
    function displayCharacterImage(personaName, character, matchedImage) {
        // 确保角色仍然存在
        if (!character || !personas[personaName]) {
            if (characterHeadImages[personaName]) {
                if (characterHeadImages[personaName].displayTimer) {
                    clearTimeout(characterHeadImages[personaName].displayTimer);
                }
                characterHeadImages[personaName] = null;
            }
            return;
        }
        
        // 获取当前游戏缩放比例
        const currentZoom = app.stage.scale.x;
        
        // 创建图片精灵
        const texture = matchedImage.texture;
        
        // 创建一个新的矩形来裁剪纹理的左上角四分之一
        const origWidth = texture.orig.width;
        const origHeight = texture.orig.height;
        const cropWidth = origWidth;  // 完整的宽度
        const cropHeight = origHeight; // 完整的高度
        
        // 创建裁剪后的纹理
        const cropRect = new PIXI.Rectangle(0, 0, cropWidth, cropHeight);
        const croppedTexture = new PIXI.Texture(texture.baseTexture, cropRect);
        
        // 创建一个简单的容器，使用全局位置
        const container = new PIXI.Container();
        container.sortableChildren = true;
        container.zIndex = 1000;
        
        // 设置基础位置
        container.x = character.x;
        
        // 计算y偏移量，基于缩放级别动态调整
        // 使用双曲线函数计算：当zoom=0.1时y偏移=-800，当zoom=1时y偏移=-200
        // 双曲线算法考虑了缩放比例的非线性变化（0.1→0.2是2倍，而0.2→0.3是1.5倍）
        const minOffset = -800;  // 缩放0.1时的偏移值
        const maxOffset = -200;  // 缩放1时的偏移值
        const minZoom = 0.1;     // 最小缩放级别
        const maxZoom = 1;       // 最大缩放级别
        
        // 确保缩放值在有效范围内
        const safeZoom = Math.max(minZoom, Math.min(maxZoom, currentZoom));
        
        // 使用双曲线函数计算缩放因子，而不是线性插值
        // 公式: (1 - minZoom/zoom) / (1 - minZoom/maxZoom)
        // 这样在小缩放值时变化较大，大缩放值时变化较小
        const zoomFactor = (1 - minZoom/safeZoom) / (1 - minZoom/maxZoom);
        
        // 计算当前缩放下的y偏移值
        const yOffset = minOffset + (maxOffset - minOffset) * zoomFactor;
        
        // 输出调试信息到控制台
        console.log("当前游戏缩放:", currentZoom, "非线性缩放因子:", zoomFactor, "计算的y偏移:", yOffset);
        
        // 应用计算后的偏移值
        container.y = character.y + yOffset ; // npc图片显示高度
        // [图像缩放设置3] - 在位置更新时保持缩放比例一致 (参考备份文件逻辑并整体缩小)
        if (currentZoom > 0) {
            // 使用线性插值来设置图片大小
            // 当zoom=0.1 (远景)时，使用较大的缩放系数；当zoom=1 (近景)时，使用较小的缩放系数
            const minImageScale = 2.1;    // 远景(zoom 0.1)时的图片缩放系数 (放大)
            const maxImageScale = 0.7;  // 近景(zoom 1.0)时的图片缩放系数 (放大)
            
            // 计算当前缩放下的图片缩放系数
            const dynamicImageScale = minImageScale + (zoomFactor * (maxImageScale - minImageScale));
            
            // 基础系数 × 动态系数 × 气泡比例
            container.scale.set((1 / currentZoom) * bubbleScale * dynamicImageScale * imageScale);
            
            // 输出调试信息到控制台
            console.log("当前游戏缩放(位置更新时):", currentZoom, 
                        "计算的y偏移:", yOffset, 
                        "图片缩放系数:", dynamicImageScale);
        }
        
        // --- 调整RenderTexture尺寸以匹配缩小的图片 --- 
        // 1. 计算图片应用imageScale后的目标显示尺寸
        const targetSpriteWidth = cropWidth * imageScale;
        const targetSpriteHeight = cropHeight * imageScale;
        
        // 2. 设定RenderTexture的边距（用于圆角、边框、阴影）
        const rtPadding = 15; // 减少边距，让背景框更紧凑
        
        // 3. 计算RenderTexture的最终宽高
        const rtWidth = Math.ceil(targetSpriteWidth + rtPadding * 2);
        const rtHeight = Math.ceil(targetSpriteHeight + rtPadding * 2);

        // 4. 使用新的尺寸创建RenderTexture
        const renderTexture = PIXI.RenderTexture.create({
            width: rtWidth,
            height: rtHeight
        });
        
        // 临时容器用于渲染
        const tempContainer = new PIXI.Container();
        
        // --- 在新的RenderTexture内绘制 --- 
        // 使用目标显示尺寸作为遮罩/边框的基础尺寸
        const maskSize = Math.min(targetSpriteWidth, targetSpriteHeight);
        
        // 创建圆角矩形遮罩
        const mask = new PIXI.Graphics();
        mask.beginFill(0xFFFFFF);
        const cornerRadius = Math.max(maskSize * 0.1, 10); // 圆角半径调整为基于新尺寸
        
        // 绘制圆角矩形 (遮罩)，在新的RenderTexture中居中
        mask.drawRoundedRect(
            (rtWidth - maskSize) / 2,
            (rtHeight - maskSize) / 2,
            maskSize, 
            maskSize, 
            cornerRadius
        );
        mask.endFill();
        tempContainer.addChild(mask);
        
        // 添加装饰性边框
        const border = new PIXI.Graphics();
        border.lineStyle(3, 0xFFFFFF, 0.4); // 边框宽度减小
        border.drawRoundedRect(
            (rtWidth - maskSize) / 2 - 2, // 边框偏移调整
            (rtHeight - maskSize) / 2 - 2,
            maskSize + 4, // 边框尺寸调整
            maskSize + 4,
            cornerRadius + 2 // 边框圆角调整
        );
        
        // 绘制阴影效果
        const shadow = new PIXI.Graphics();
        shadow.beginFill(0x000000, 0.3);
        shadow.drawRoundedRect(
            (rtWidth - maskSize) / 2 + 3, // 阴影偏移调整
            (rtHeight - maskSize) / 2 + 3,
            maskSize,
            maskSize,
            cornerRadius
        );
        shadow.endFill();
        
        tempContainer.addChild(shadow); // 先添加阴影
        tempContainer.addChild(border); // 再添加边框
        
        // 使用裁剪后的纹理创建精灵
        const sprite = new PIXI.Sprite(croppedTexture);
        
        // --- 调整精灵在RenderTexture内的缩放和位置 --- 
        // 将精灵缩放到其在遮罩区域的目标尺寸
        sprite.width = maskSize;
        sprite.height = maskSize; 
        
        // 在新的RenderTexture中居中精灵
        sprite.x = (rtWidth - sprite.width) / 2;
        sprite.y = (rtHeight - sprite.height) / 2;
        sprite.mask = mask;
        tempContainer.addChild(sprite);
        
        // 渲染到纹理
        app.renderer.render(tempContainer, {renderTexture});
        
        // 创建最终显示的精灵
        const finalSprite = new PIXI.Sprite(renderTexture);
        finalSprite.anchor.set(0.5, 0.5); // 居中锚点
        
        // 添加从模糊到清晰的加载特效
        const blurFilter = new PIXI.filters.BlurFilter();
        blurFilter.blur = 12; // 初始模糊度，可以调整
        finalSprite.filters = [blurFilter];

        // 动画参数
        let currentBlur = blurFilter.blur;
        const targetBlur = 0;
        const animationDuration = 1500; // 动画持续时间 (毫秒)，例如 1.5 秒
        const startTime = Date.now();

        function animateBlur() {
            const elapsedTime = Date.now() - startTime;
            const progress = Math.min(elapsedTime / animationDuration, 1);

            currentBlur = blurFilter.blur * (1 - progress); // 线性减少模糊
            blurFilter.blur = currentBlur;

            if (progress < 1) {
                requestAnimationFrame(animateBlur);
            } else {
                blurFilter.blur = 0; // 确保最终完全清晰
                finalSprite.filters = null; // 动画结束后移除滤镜以提高性能
                console.log(`${personaName} 的图片已清晰显示`);
            }
        }
        // 延迟一点点启动动画，确保精灵已准备好
        requestAnimationFrame(animateBlur);

        // 销毁临时对象
        tempContainer.destroy({children: true});
        
        // 添加到独立的图片容器
        container.addChild(finalSprite);
        
        // [图像缩放设置2] - 应用反向缩放，保持大小不受游戏缩放影响 (放大)
        if (currentZoom > 0) {
            // 使用线性插值来设置图片大小
            // 当zoom=0.1 (远景)时，使用较大的缩放系数；当zoom=1 (近景)时，使用较小的缩放系数
            const minImageScale = 2.1;    // 远景(zoom 0.1)时的图片缩放系数 (放大)
            const maxImageScale = 0.7;  // 近景(zoom 1.0)时的图片缩放系数 (放大)
            
            // 计算当前缩放下的图片缩放系数
            const dynamicImageScale = minImageScale + (zoomFactor * (maxImageScale - minImageScale));
            
            // 基础系数 × 动态系数 × 气泡比例
            container.scale.set((1 / currentZoom) * bubbleScale * dynamicImageScale * imageScale);
            
            // 输出调试信息到控制台
            console.log("当前游戏缩放(最终应用时):", currentZoom, 
                       "计算的y偏移:", yOffset, 
                       "图片缩放系数:", dynamicImageScale);
        }
        
        // 添加到全局图片容器
        imageContainer.addChild(container);
        
        // 更新图片信息
        characterHeadImages[personaName] = {
            container: container,
            sprite: finalSprite,
            renderTexture: renderTexture,
            currentImagePath: matchedImage.path,
            timestamp: matchedImage.timestamp,
            active: true,
            pendingDisplay: false,
            // 设置自动隐藏图片
            timer: setTimeout(() => {
                if (characterHeadImages[personaName]) {
                    // 渐隐效果
                    const fadeOut = () => {
                        if (container.alpha > 0.1) {
                            container.alpha -= 0.1;
                            requestAnimationFrame(fadeOut);
                        } else {
                            // 完全移除并销毁所有资源
                            if (container.parent) {
                                container.parent.removeChild(container);
                            }
                            
                            // 销毁渲染纹理
                            if (renderTexture) {
                                renderTexture.destroy(true);
                            }
                            
                            // 销毁容器及其所有子元素
                            container.destroy({children: true, texture: true, baseTexture: true});
                            
                            // 清除定时器
                            if (characterHeadImages[personaName] && 
                                characterHeadImages[personaName].timer) {
                                clearTimeout(characterHeadImages[personaName].timer);
                            }
                            
                            // 移除引用
                            characterHeadImages[personaName] = null;
                        }
                    };
                    fadeOut();
                }
            }, 15000) // 15秒后隐藏
        };
        
        console.log(`显示${personaName}在${matchedImage.timestamp}的图片`);
    }

    // 游戏设置
    function setupGame(resources) {
        console.log("设置游戏...");
        console.log("可用资源键名:", Object.keys(resources));
        
        // 检查关键资源是否存在
        if (!resources.map) {
            console.error("地图资源不存在，检查资源路径和加载过程");
            showSystemMessage("地图资源加载失败，请检查网络连接");
        }
        
        // 创建地图容器
        mapContainer = new PIXI.Container();
        mapContainer.zIndex = 1; // 最低层
        app.stage.addChild(mapContainer);
        
        // 创建角色容器
        const characterContainer = new PIXI.Container();
        characterContainer.sortableChildren = true; // 确保深度排序
        characterContainer.zIndex = 2; // 角色在地图上方
        app.stage.addChild(characterContainer);
        
        // 创建专门用于头顶图片的容器
        imageContainer = new PIXI.Container();
        imageContainer.sortableChildren = true; // 确保深度排序
        imageContainer.zIndex = 3; // 确保图片在角色上方
        app.stage.addChild(imageContainer);
        
        // 启用深度排序
        app.stage.sortableChildren = true;
        app.stage.sortChildren();
        
        // 创建地图
        createMap(resources);
        
        // 创建UI (现在使用DOM元素而非PixiJS)
        createUI();
        
        // 设置玩家角色
        console.log("创建玩家角色...");
        try {
            let playerTexture = null;
            let playerResourceKey = null;
            
            // 优先使用默认玩家纹理
            if (resources.default_player_spritesheet && resources.default_player_spritesheet.texture) {
                playerTexture = resources.default_player_spritesheet.texture;
                playerResourceKey = 'default_player_spritesheet';
                console.log("使用默认玩家纹理");
            } else {
                // 如果默认纹理不可用，查找第一个可用的角色纹理
                for (let key in resources) {
                    if (key.endsWith('_spritesheet') && resources[key] && resources[key].texture) {
                        playerTexture = resources[key].texture;
                        playerResourceKey = key;
                        console.log("使用备用角色纹理:", key);
                        break;
                    }
                }
            }
            
            console.log("玩家纹理资源:", playerResourceKey);
            
            if (!playerTexture) {
                throw new Error("没有找到可用的角色纹理");
            } else {
                console.log("玩家纹理尺寸:", playerTexture.width, "x", playerTexture.height);
            }
            
            // 创建玩家角色
            player = createCharacter('player', 6000, 3000, playerTexture);
            player.zIndex = 2;
            characterContainer.addChild(player);
            
            // 将玩家添加到personas对象中，以便角色选择功能正常工作
            personas['玩家'] = player;
            
            console.log("玩家角色创建成功，使用纹理:", playerResourceKey);
        } catch (error) {
            console.error("创建玩家失败:", error);
            // 创建一个占位符作为后备
            player = createCharacterPlaceholder(2500, 2495);
            characterContainer.addChild(player);
            
            // 将占位符玩家也添加到personas对象中
            personas['玩家'] = player;
            
            console.log("使用占位符替代玩家角色");
        }
        
        // 设置NPC角色
        console.log("创建NPC角色...");
        console.log("要创建的NPC:", Object.keys(persona_names));
        
        let successfulNPCs = 0;
        let failedNPCs = 0;
        
        for (let p in persona_names) {
            if (p === '实验者') continue; // 跳过玩家角色
            
            try {
                console.log(`开始创建NPC: ${p}`);
                const startPos = spawn_tile_loc[p];
                if (!startPos) {
                    console.error(`NPC ${p} 没有起始位置`);
                    failedNPCs++;
                    continue;
                }
                
                const x = startPos[0] * tile_width + tile_width / 2 - 10;
                const y = startPos[1] * tile_width + tile_width - 5; // 将NPC上移5个像素
                
                console.log(`NPC ${p} 位置: ${x}, ${y}`);
                
                // 检查PNG资源是否可用
                const resourceKey = `${p}_spritesheet`;
                console.log(`检查NPC资源: ${resourceKey}`);
                
                if (!resources[resourceKey]) {
                    console.error(`未找到NPC ${p} 的资源, 尝试使用替代方法`);
                    
                    // 尝试使用通用NPC资源或创建占位符
                    const npc = createCharacterPlaceholder(x, y);
                    npc.zIndex = 2;
                    characterContainer.addChild(npc);
                    personas[p] = npc;
                    
                    // 初始化动画方向字典
                    pre_anims_direction_dict[p] = "d"; // 默认朝下
                    
                    // 创建对话气泡
                    createDialogueBubble(npc, p);
                    console.log(`NPC ${p} 使用占位符创建完成`);
                    failedNPCs++;
                    continue;
                }
                
                if (!resources[resourceKey].texture) {
                    console.error(`NPC ${p} 的PNG纹理不可用`);
                    failedNPCs++;
                    continue;
                } else {
                    console.log(`NPC ${p} 纹理尺寸:`, resources[resourceKey].texture.width, "x", resources[resourceKey].texture.height);
                }
                
                // 创建NPC角色
                const npc = createCharacter(p, x, y, resources[resourceKey].texture);
                npc.zIndex = 2;
                characterContainer.addChild(npc);
                personas[p] = npc;
                
                // 初始化动画方向字典
                pre_anims_direction_dict[p] = "d"; // 默认朝下
                
                // 创建对话气泡
                createDialogueBubble(npc, p);
                console.log(`NPC ${p} 创建完成`);
                successfulNPCs++;
            } catch (error) {
                console.error(`创建NPC ${p} 时出错:`, error);
                failedNPCs++;
                
                // 添加占位符作为后备
                const startPos = spawn_tile_loc[p] || [100, 100]; // 如果没有位置信息，使用默认值
                const x = startPos[0] * tile_width + tile_width / 2 - 10;
                const y = startPos[1] * tile_width + tile_width - 5; // 将后备NPC也上移5个像素
                
                const npc = createCharacterPlaceholder(x, y);
                npc.zIndex = 2;
                characterContainer.addChild(npc);
                personas[p] = npc;
                
                // 初始化动画方向字典
                pre_anims_direction_dict[p] = "d"; // 默认朝下
                
                // 创建对话气泡
                createDialogueBubble(npc, p);
                console.log(`NPC ${p} 使用占位符替代`);
            }
        }
        
        console.log(`NPC创建完成: 成功 ${successfulNPCs}个, 失败 ${failedNPCs}个`);
        
        // 确保深度排序
        characterContainer.sortChildren();
        app.stage.sortChildren();
        
        // 设置键盘控制
        setupKeyboardControls();
        
        // 确保所有碰撞框隐藏
        showAllCollisionBoxes(false);
        
        // 强制更新UI确保可见
        forceUpdateUI();
        
        // 应用Canvas优化
        setCanvasWillReadFrequently();
        
        // 开始游戏循环
        app.ticker.add(gameLoop);
        
        console.log("游戏设置完成");
        
        // 显示系统消息通知用户游戏已准备就绪
        setTimeout(() => {
            showSystemMessage("✨ 游戏世界已加载完成 ✨", 4000);
        }, 500);
    }
    
    // 创建地图
    function createMap(resources) {
        try {
            if (!resources.map || !resources.map.data) {
                console.error("地图数据未能正确加载");
                createSimpleBackground();
                showSystemMessage("地图数据加载失败，使用简单背景替代");
                return;
            }

            const mapData = resources.map.data;
            
            // 创建基础背景
            createSimpleBackground();

            // 获取瓦片集信息
            const tilesets = mapData.tilesets;
            
            // 预先检查瓦片集资源
            let allTilesetsAvailable = true;
            const loadedTilemapKeys = Object.keys(resources).filter(key => key.startsWith('tilemap_'));
            console.log('可用的瓦片集资源:', loadedTilemapKeys);

            // 检查JSON中定义的瓦片集是否都有对应的加载资源
            // 由于 tilemap.json 读取持续失败，暂时跳过这个检查，并假设所有 tilemap_ 开头的资源都是有效的
            /*
            for (let i = 0; i < tilesets.length; i++) {
                const tileset = tilesets[i];
                // 尝试从文件名（不含扩展名）推断资源键
                const imageName = tileset.image.split('/').pop().split('.').slice(0, -1).join('.');
                const textureKey = `tilemap_${imageName}`;
                if (!resources[textureKey] || !resources[textureKey].texture) {
                    console.warn(`瓦片集 ${tileset.name} (对应图片 ${tileset.image}, 期望键 ${textureKey}) 未加载或无效`);
                    // allTilesetsAvailable = false; // 暂时不因为这个设置为false，允许地图部分渲染
                } else {
                    console.log(`瓦片集 ${tileset.name} (资源键 ${textureKey}) 已加载`);
                }
            }
            */

            if (loadedTilemapKeys.length === 0) {
                console.error("没有可用的瓦片集图片资源，地图可能无法正确显示");
                showSystemMessage("地图图片资源加载失败");
                allTilesetsAvailable = false;
            }


            // 创建瓦片地图层
            let visibleLayerCount = 0;
            
            mapData.layers.forEach((layer, index) => {
                if (layer.type === "tilelayer") {
                    const layerContainer = new PIXI.Container();
                    
                    // 设置图层透明度
                    let layerVisible = true;
                    if (layer.visible === false) {
                        layerContainer.visible = false;
                        layerVisible = false;
                    } else {
                        visibleLayerCount++;
                    }
                    
                    if (layer.opacity !== undefined) {
                        layerContainer.alpha = layer.opacity;
                    }
                    
                    // 渲染图层瓦片
                    let tileCount = 0;
                    
                    for (let y = 0; y < layer.height; y++) {
                        for (let x = 0; x < layer.width; x++) {
                            const tileIndex = y * layer.width + x;
                            const tileId = layer.data[tileIndex];
                            
                            if (tileId !== 0) {  // 0 表示空瓦片
                                tileCount++;
                                
                                // 找到对应的瓦片集
                                let tileset = null;
                                let tilesetIndex = 0;
                                
                                for (let i = 0; i < tilesets.length; i++) {
                                    if (tileId >= tilesets[i].firstgid && 
                                        (!tilesets[i+1] || tileId < tilesets[i+1].firstgid)) {
                                        tileset = tilesets[i];
                                        tilesetIndex = i + 1;
                                        break;
                                    }
                                }
                                
                                if (tileset) {
                                    // 从 tileset.image 中提取文件名作为键的一部分
                                    const imageName = tileset.image.split('/').pop().split('.').slice(0, -1).join('.');
                                    const textureKey = `tilemap_${imageName}`;

                                    if (resources[textureKey] && resources[textureKey].texture) {
                                        // 计算瓦片在瓦片集中的位置
                                        const localId = tileId - tileset.firstgid;
                                        const tilesPerRow = Math.floor(tileset.imagewidth / tileset.tilewidth);
                                        const tileX = (localId % tilesPerRow) * tileset.tilewidth;
                                        const tileY = Math.floor(localId / tilesPerRow) * tileset.tileheight;
                                        
                                        try {
                                            // 创建瓦片精灵
                                            const texture = new PIXI.Texture(
                                                resources[textureKey].texture.baseTexture,
                                                new PIXI.Rectangle(tileX, tileY, tileset.tilewidth, tileset.tileheight)
                                            );
                                            const tile = new PIXI.Sprite(texture);
                                            
                                            // 设置瓦片位置
                                            tile.x = x * tile_width;
                                            tile.y = y * tile_width;
                                            
                                            layerContainer.addChild(tile);
                                        } catch (error) {
                                            console.error(`创建瓦片时出错 (图层: ${layer.name}, 位置: ${x},${y}, 瓦片ID: ${tileId}):`, error);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // 设置特定图层的透明度
                    if (layer.name.startsWith("1") || layer.name.startsWith("2")) {
                        if (layer.name.includes("音乐区")) {
                            layerContainer.alpha = 0.02;
                        } else {
                            layerContainer.alpha = 0.3;
                        }
                    }
                    
                    mapContainer.addChild(layerContainer);
                }
            });

            // 添加缩放和位置调整
            mapContainer.scale.set(1);
            mapContainer.position.set(0, 0);
            
            // 添加视口跟随
            app.stage.position.set(app.screen.width / 2, app.screen.height / 2);
            app.stage.pivot.set(2500, 2500);

        } catch (error) {
            console.error("创建地图失败:", error);
            createSimpleBackground();
        }
    }
    
    
    // 创建实验者单的背景
    function createSimpleBackground() {
        console.log("创建实验者单背景");
        const bg = new PIXI.Graphics();
        
        // 创建大背景，背景颜色 (已注释掉)
        // bg.beginFill(0x0a0a0a);  // 纯黑背景以匹配黑金主题
        // bg.drawRect(0, 0, 5000, 5000);
        // bg.endFill();
        
        // 添加网格 (已注释掉)
        // bg.lineStyle(1, 0xCCCCCC, 0.3);
        // for (let i = 0; i <= 5000; i += tile_width) {
        //     bg.moveTo(i, 0);
        //     bg.lineTo(i, 5000);
        //     bg.moveTo(0, i);
        //     bg.lineTo(5000, i);
        // }
        
        // 添加参考点
        bg.lineStyle(2, 0xFF0000, 0.5);
        bg.drawCircle(2500, 2500, 50); // 玩家初始位置标记
        
        // 添加区域标记
        bg.lineStyle(2, 0x0000FF, 0.5);
        for (let p in spawn_tile_loc) {
            const pos = spawn_tile_loc[p];
            const x = pos[0] * tile_width;
            const y = pos[1] * tile_width;
            bg.drawRect(x, y, tile_width, tile_width);
        }
        
        mapContainer.addChild(bg);
        console.log("实验者单背景创建完成");
    }
    
    // 创建角色
    function createCharacter(textureName, x, y, baseTexture = null) {
        try {
            const container = new PIXI.Container();
            container.sortableChildren = true;
            
            container.textureInfo = {
                name: textureName,
                spritesheet: baseTexture,
                frame: 0,
                totalFrames: 24,
                rows: 5,
                cols: 5,
                frameWidth: baseTexture.width / 5,
                frameHeight: baseTexture.height / 5
            };
            
            function createFrameTexture(frame) {
                const col = frame % 5;
                const row = Math.floor(frame / 5);
                return new PIXI.Texture(
                    baseTexture,
                    new PIXI.Rectangle(
                        col * container.textureInfo.frameWidth,
                        row * container.textureInfo.frameHeight,
                        container.textureInfo.frameWidth,
                        container.textureInfo.frameHeight
                    )
                );
            }
            
            const sprite = new PIXI.Sprite(createFrameTexture(0));
            sprite.anchor.set(0.5, 0.5);
            sprite.scale.set(0.21); // 原为0.14, 放大1.5倍
            sprite.x = 0;
            sprite.y = -17; // 向上偏移12像素 (原为-5)
            sprite.zIndex = 1;
            
            container.addChild(sprite);
            
            const collisionBox = new PIXI.Graphics();
            collisionBox.lineStyle(4, 0xFF0000, 1);
            collisionBox.beginFill(0xFF0000, 0.3);
            collisionBox.drawRect(-16, 1, 32, 32); // 向上偏移12像素 (原为13)
            collisionBox.endFill();
            
            collisionBox.lineStyle(2, 0xFFFFFF, 1);
            collisionBox.moveTo(-16, 25); // 向上偏移12像素 (原为37)
            collisionBox.lineTo(16, 25);  // 向上偏移12像素 (原为37)
            collisionBox.moveTo(0, 9);    // 向上偏移12像素 (原为21)
            collisionBox.lineTo(0, 41);   // 向上偏移12像素 (原为53)
            
            collisionBox.zIndex = 1000;
            collisionBox.visible = false;
            
            const collisionText = new PIXI.Text("碰撞框", {
                fontSize: 10,
                fill: 0xFFFFFF,
                fontWeight: 'bold',
                stroke: 0x000000,
                strokeThickness: 3,
                align: 'center'
            });
            collisionText.x = -15;
            collisionText.y = 18; // 向上偏移12像素 (原为30)
            collisionText.visible = false;
            collisionBox.addChild(collisionText);
            
            container.addChild(collisionBox);
            container.collisionBox = collisionBox;
            
            container.x = x;
            container.y = y;
            container.zIndex = 2;
            
            container.hitArea = new PIXI.Rectangle(-16, 9, 32, 32); // 向上偏移12像素 (原为21)
            
            container.animationState = {
                direction: 'down',
                isMoving: false,
                frameCounter: 0,
                frameDelay: textureName === 'player' ? 6 : 6,
                currentFrameSet: {
                    start: 0,
                    end: 5
                }
            };
            
            // 定义动画帧范围配置
            const ANIMATION_SETS = {
                moving: {
                    left: { start: 0, end: 5 },
                    down: { start: 0, end: 5 },
                    right: { start: 6, end: 11 },
                    up: { start: 6, end: 11 }
                },
                idle: {
                    left: { start: 12, end: 17 },
                    down: { start: 12, end: 17 },
                    right: { start: 18, end: 23 },
                    up: { start: 18, end: 23 }
                }
            };
            
            container.updateAnimation = function(direction, isMoving) {
                this.animationState.direction = direction;
                this.animationState.isMoving = isMoving;
                
                // 更新帧延迟
                if (textureName !== 'player') {
                    this.animationState.frameDelay = isMoving ? 4 : 8;
                }
                
                // 获取当前状态的帧范围
                const state = isMoving ? 'moving' : 'idle';
                const frameSet = ANIMATION_SETS[state][direction];
                this.animationState.currentFrameSet = frameSet;
                
                // 更新帧
                this.animationState.frameCounter++;
                if (this.animationState.frameCounter >= this.animationState.frameDelay) {
                    this.animationState.frameCounter = 0;
                    
                    const currentFrame = this.textureInfo.frame;
                    const { start, end } = frameSet;
                    
                    // 计算下一帧
                    this.textureInfo.frame = currentFrame < start || currentFrame >= end
                        ? start
                        : currentFrame + 1 > end ? start : currentFrame + 1;
                    
                    // 更新纹理
                    sprite.texture = createFrameTexture(this.textureInfo.frame);
                }
            };
            
            return container;
        } catch (error) {
            console.error(`创建角色 ${textureName} 失败:`, error);
            return createCharacterPlaceholder(x, y);
        }
    }
    
    // 创建自定义SVG动画
    function createSvgAnimations(baseTexture) {
        const spriteWidth = baseTexture.width / 5;
        const spriteHeight = baseTexture.height / 5;
        
        const animations = {
            down: { walk: [], idle: [] },
            left: { walk: [], idle: [] },
            right: { walk: [], idle: [] },
            up: { walk: [], idle: [] }
        };
        
        try {
            // 创建24帧的纹理数组
            const frames = Array.from({ length: 24 }, (_, i) => {
                const x = (i % 5) * spriteWidth;
                const y = Math.floor(i / 5) * spriteHeight;
                return new PIXI.Texture(
                    baseTexture,
                    new PIXI.Rectangle(x, y, spriteWidth, spriteHeight)
                );
            });
            
            // 分配帧到不同的动画状态
            const frameRanges = {
                walk: {
                    left: [0, 5],    // 1-6帧用于左走
                    down: [0, 5],    // 1-6帧用于下走
                    right: [6, 11],  // 7-12帧用于右走
                    up: [6, 11]      // 7-12帧用于上走
                },
                idle: {
                    left: [12, 17],  // 13-18帧用于左待机
                    down: [12, 17],  // 13-18帧用于下待机
                    right: [18, 23], // 19-24帧用于右待机
                    up: [18, 23]     // 19-24帧用于上待机
                }
            };
            
            // 为每个方向和状态分配帧
            Object.entries(frameRanges).forEach(([state, directions]) => {
                Object.entries(directions).forEach(([direction, [start, end]]) => {
                    animations[direction][state] = frames.slice(start, end + 1);
                });
            });
            
            return animations;
        } catch (error) {
            // 创建后备动画
            const defaultFrame = new PIXI.Texture(
                baseTexture,
                new PIXI.Rectangle(0, 0, spriteWidth, spriteHeight)
            );
            
            Object.values(animations).forEach(states => {
                Object.keys(states).forEach(state => {
                    states[state] = [defaultFrame];
                });
            });
            
            return animations;
        }
    }
    
    // 创建角色占位符
    function createCharacterPlaceholder(x, y) {
        const container = new PIXI.Container();
        container.sortableChildren = true;
        
        // 创建基础图形
        const placeholder = new PIXI.Graphics();
        placeholder.beginFill(0xFF0000);
        placeholder.drawCircle(0, -5, 16);
        placeholder.endFill();
        
        placeholder.lineStyle(2, 0xFFFFFF, 1);
        placeholder.moveTo(-16, -5);
        placeholder.lineTo(16, -5);
        placeholder.moveTo(0, -21);
        placeholder.lineTo(0, 11);
        
        placeholder.zIndex = 1;
        container.addChild(placeholder);
        
        // 创建碰撞框
        const collisionBox = new PIXI.Graphics();
        collisionBox.lineStyle(4, 0xFF0000, 1);
        collisionBox.beginFill(0xFF0000, 0.3);
        collisionBox.drawRect(-16, 3, 32, 32);
        collisionBox.endFill();
        
        collisionBox.lineStyle(2, 0xFFFFFF, 1);
        collisionBox.moveTo(-16, 27);
        collisionBox.lineTo(16, 27);
        collisionBox.moveTo(0, 11);
        collisionBox.lineTo(0, 43);
        
        collisionBox.zIndex = 1000;
        collisionBox.visible = false;
        container.addChild(collisionBox);
        container.collisionBox = collisionBox;
        
        // 设置容器属性
        container.x = x;
        container.y = y;
        container.zIndex = 2;
        
        // 添加空的动画更新方法
        container.updateAnimation = function() {};
        
        return container;
    }
    
    // 创建对话气泡
    function createDialogueBubble(personaSprite, personaName) {
        // 创建基础容器
        const dialogueContainer = new PIXI.Container();
        dialogueContainer.name = `dialogue_${personaName}`;
        dialogueContainer.zIndex = 9999;
        
        // 创建背景和文本
        const background = new PIXI.Graphics();
        background.name = "dialogue_bg";
        
        const text = new PIXI.Text("", {
            fontFamily: 'Arial',
            fontSize: 14,
            fill: 0x000000,
            align: 'left',
            wordWrap: true,
            wordWrapWidth: 40,
            lineHeight: 10
        });
        text.name = "dialogue_text";
        text.x = 8;
        text.y = 4;
        
        // 组装气泡
        dialogueContainer.addChild(background);
        dialogueContainer.addChild(text);
        
        // 设置位置和可见性
        dialogueContainer.x = personaSprite.width / 2 - 100;
        dialogueContainer.y = -70;
        dialogueContainer.visible = false;
        
        // 添加到角色精灵
        personaSprite.addChild(dialogueContainer);
        
        // 记录气泡引用
        pronunciatios[personaName] = {
            container: dialogueContainer,
            background: background,
            text: text,
            personaName: personaName
        };
    }
    
    // 应用统一的文本样式
    function applyBubbleTextStyle(textStyle, bubbleType = "dialog") {
        return {
            ...textStyle,
            wordWrap: bubbleType === "dialog",
            fontSize: bubbleType === "action" ? 12 : 14,
            wordWrapWidth: 40,
            lineHeight: 10
        };
    }
    
    // 格式化气泡文本
    function formatBubbleText(text) {
        if (!text?.trim()) return "";
        
        // 短文本不需要分行
        if (text.length <= 5) return text;
        
        // 计算每行字符数
        const charsPerLine = Math.ceil(text.length / 2);
        
        // 查找合适的断句点
        const breakPoints = [',', '，', '.', '。', '!', '！', '?', '？', ';', '；', ':', '：'];
        let bestBreakIndex = -1;
        
        // 在理想长度70%到100%范围内寻找最佳断句点
        for (let i = Math.floor(charsPerLine * 0.7); i <= charsPerLine; i++) {
            if (breakPoints.includes(text[i])) {
                bestBreakIndex = i + 1;
                break;
            }
        }
        
        // 如果没找到合适的断句点，就在理想长度处断开
        if (bestBreakIndex === -1) {
            bestBreakIndex = charsPerLine;
        }
        
        // 分成两行
        return text.slice(0, bestBreakIndex) + '\n' + text.slice(bestBreakIndex);
    }
    
    // 更新气泡位置
    function updateBubblePosition(personaName) {
        const bubble = pronunciatios[personaName];
        if (!bubble?.container || !bubble?.background || !bubble?.text) return;

        const currentZoom = app.stage.scale.x;
        const npc = personas[personaName];
        if (!npc) return;

        // 计算气泡尺寸
        const bubbleWidth = bubble.background.width;
        const bubbleHeight = bubble.background.height;
        
        // 重置气泡缩放以进行正确的位置计算
        bubble.container.scale.set(1);
        
        // 计算气泡位置
        const scaledBubbleWidth = bubbleWidth / currentZoom;
        const scaledBubbleHeight = bubbleHeight / currentZoom;
        
        // 水平居中并应用偏移
        bubble.container.x = (npc.width - scaledBubbleWidth) / 2 + bubbleHorizontalOffset;
        
        // 垂直位置调整
        bubble.container.y = -bubbleVerticalOffset - scaledBubbleHeight;
        
        // 应用反向缩放和全局气泡缩放
        if (currentZoom > 0) {
            bubble.container.scale.set((1 / currentZoom) * bubbleScale);
        }
        
        // 确保气泡在最上层
        bubble.container.zIndex = 10000;
        npc.sortChildren();
    }
    
    // 更新所有NPC气泡位置
    function updateAllBubblePositions() {
        Object.keys(pronunciatios).forEach(updateBubblePosition);
    }
    
    // 创建UI
    function createUI() {
        // 获取DOM上的UI容器
        const uiBottomPanel = document.getElementById('ui-bottom-panel');
        const uiDialogPanel = document.getElementById('ui-dialog-panel');
        
        if (!uiBottomPanel || !uiDialogPanel) {
            console.error("找不到UI容器元素");
            return;
        }
        
        // 确保对话面板默认隐藏
        uiDialogPanel.style.display = 'none';
        
        // 初始化对话面板样式
        initDialogPanel();
        
        // 清空按钮容器
        uiBottomPanel.innerHTML = '';
        
        // 创建左侧按钮容器 (主控制按钮)
        const leftButtonsContainer = document.createElement('div');
        leftButtonsContainer.className = 'control-group'; // Use new class
        uiBottomPanel.appendChild(leftButtonsContainer);
        
        // 创建中间控制容器（用于缩放和比例控制）
        const centerControlsContainer = document.createElement('div');
        centerControlsContainer.className = 'control-group'; // Use new class
        centerControlsContainer.style.marginLeft = '10px'; // Reduced margin
        uiBottomPanel.appendChild(centerControlsContainer);
        
        // 创建右侧时间显示容器
        const rightInfoContainer = document.createElement('div');
        rightInfoContainer.className = 'ui-bottom-panel-right'; // Use new class
        uiBottomPanel.appendChild(rightInfoContainer);
        
        // Updated button creation logic
        function createControlButton(text, id, className, onClick) {
            const button = document.createElement('button');
            button.textContent = text;
            if (id) button.id = id;
            button.className = `ui-button ${className}`; // Apply base and specific class
            button.addEventListener('click', onClick);
            return button;
        }
        
        // 创建游戏控制按钮
        buttonPlay = createControlButton("▶ 运行", "btn-play", "ui-button-success", () => {
            if (finished) return;
            buttonPlay.innerHTML = "▶ [运行]"; // Keep innerHTML for potential icons later
            buttonPlay.classList.add('active');
            buttonPause.innerHTML = "⏸ 暂停";
            buttonPause.classList.remove('active');
            paused = false;
            showSystemMessage("模拟已开始运行");
        });
        leftButtonsContainer.appendChild(buttonPlay);
        
        buttonPause = createControlButton("⏸ 暂停", "btn-pause", "ui-button-warning", () => {
            if (finished) return;
            buttonPlay.innerHTML = "▶ 运行";
            buttonPlay.classList.remove('active');
            buttonPause.innerHTML = "⏸ [暂停]";
            buttonPause.classList.add('active');
            paused = true;
            showSystemMessage("模拟已暂停");
        });
        leftButtonsContainer.appendChild(buttonPause);
        
        buttonShowConversation = createControlButton("💬 显示对话", "btn-show-convo", "ui-button-info", () => {
            buttonShowConversation.style.display = 'none';
            buttonHideConversation.style.display = 'inline-flex'; // Match .ui-button display
            if (uiDialogPanel) {
                uiDialogPanel.style.display = 'block';
                updateDialogues();
                // 当显示对话框时，我们通常希望滚动到最新的消息。
                // 'conversation-content' 上的滚动侦听器会在用户向上滚动时将 autoScrollEnabled 设置为 false。
                autoScrollEnabled = true;
                scrollToLatestMessage(); // 此函数滚动 'conversation-content'
                showSystemMessage("对话面板已显示");
            }
        });
        leftButtonsContainer.appendChild(buttonShowConversation);
        
        buttonHideConversation = createControlButton("🔇 隐藏对话", "btn-hide-convo", "ui-button-info", () => {
            buttonShowConversation.style.display = 'inline-flex';
            buttonHideConversation.style.display = 'none';
            if (uiDialogPanel) {
                uiDialogPanel.style.display = 'none';
                showSystemMessage("对话面板已隐藏");
            }
        });
        buttonHideConversation.style.display = 'none'; // Initially hidden
        leftButtonsContainer.appendChild(buttonHideConversation);
        
        const buttonSettings = createControlButton("⚙️ 设置", "btn-settings", "ui-button-secondary", () => {
            toggleSettingsWindow();
        });
        leftButtonsContainer.appendChild(buttonSettings);
        
        buttonClearConversation = createControlButton("🗑️ 清除对话", "btn-clear-convo", "ui-button-danger", () => {
            if (confirm('确定要清除所有对话记录吗？此操作不可恢复。')) {
                dialogHistory = {};
                lastSpeaker = null;
                const dialogContent = document.getElementById('conversation-content');
                const defaultDialogContent = document.getElementById('default-dialog-content');
                if (dialogContent && defaultDialogContent) {
                    dialogContent.innerHTML = '';
                    dialogContent.style.display = 'none';
                    defaultDialogContent.style.display = 'block';
                }
                showSystemMessage('对话记录已清除');
            }
        });
        leftButtonsContainer.appendChild(buttonClearConversation);
        
        // 添加缩放滑块控制
        const zoomControlContainer = document.createElement('div');
        zoomControlContainer.className = 'control-group';
        
        const zoomLabel = document.createElement('span');
        zoomLabel.textContent = '🔍 缩放:';
        zoomLabel.className = 'control-label';
        zoomControlContainer.appendChild(zoomLabel);
        
        const zoomSlider = document.createElement('input');
        zoomSlider.type = 'range';
        zoomSlider.min = '0.1';   // 最小缩放值比例
        zoomSlider.max = '1.0';   // 最大缩放值比例
        zoomSlider.step = '0.01'; // 更精细的步长以匹配输入框
        zoomSlider.value = '0.5';
        zoomSlider.style.width = '100px'; // Adjusted width
        // Styles for track and thumb are now handled by global CSS
        zoomControlContainer.appendChild(zoomSlider);

        const zoomInput = document.createElement('input');
        zoomInput.type = 'number';
        zoomInput.min = '0.1';
        zoomInput.max = '1.0';
        zoomInput.step = '0.01';
        zoomInput.value = '0.5';
        zoomInput.className = 'ui-input'; // 使用现有的输入框样式
        zoomInput.style.width = '50px'; // 调整宽度
        zoomInput.style.marginLeft = '5px';
        zoomControlContainer.appendChild(zoomInput);
        
        const zoomValueDisplay = document.createElement('span');
        zoomValueDisplay.textContent = parseFloat(zoomSlider.value).toFixed(2) + 'x'; // 显示两位小数
        zoomValueDisplay.className = 'control-value';
        zoomValueDisplay.style.marginLeft = '5px';
        zoomControlContainer.appendChild(zoomValueDisplay);
        
        zoomSlider.addEventListener('input', () => {
            const currentZoom = parseFloat(zoomSlider.value);
            zoomInput.value = currentZoom.toFixed(2);
            zoomValueDisplay.textContent = currentZoom.toFixed(2) + 'x';
            applyHighQualityZoom(currentZoom);
        });

        zoomInput.addEventListener('input', () => {
            let currentZoom = parseFloat(zoomInput.value);
            if (isNaN(currentZoom)) return; // 如果输入不是数字则忽略

            // 限制输入范围
            if (currentZoom < 0.1) currentZoom = 0.1;
            if (currentZoom > 1.0) currentZoom = 1.0;
            
            zoomInput.value = currentZoom.toFixed(2); // 格式化输入框的值
            zoomSlider.value = currentZoom.toFixed(2);
            zoomValueDisplay.textContent = currentZoom.toFixed(2) + 'x';
            applyHighQualityZoom(currentZoom);
        });

        // 处理输入框失焦时，确保值在范围内并格式化
        zoomInput.addEventListener('blur', () => {
            let currentZoom = parseFloat(zoomInput.value);
            if (isNaN(currentZoom)) {
                currentZoom = parseFloat(zoomSlider.value); // 无效输入则恢复滑块值
            } else {
                if (currentZoom < 0.1) currentZoom = 0.1;
                if (currentZoom > 1.0) currentZoom = 1.0;
            }
            zoomInput.value = currentZoom.toFixed(2);
            zoomSlider.value = currentZoom.toFixed(2);
            zoomValueDisplay.textContent = currentZoom.toFixed(2) + 'x';
            // applyHighQualityZoom(currentZoom); // 可选：失焦时是否立即应用，通常input事件已处理
        });
        centerControlsContainer.appendChild(zoomControlContainer);
        
        // 添加外星代码按钮
        const webSimButton = createControlButton("👽 外星代码模拟", "btn-web-sim", "ui-button-info", () => {
            toggleWebSimPanel(); // 这个函数名 toggleWebSimPanel 内部的标题也已修改为 "外星代码模拟"
        });
        centerControlsContainer.appendChild(webSimButton);
        
        // 添加外星音乐按钮
        const musicButton = createControlButton("🎵 外星音乐", "btn-music", "ui-button-purple", () => {
            toggleMusicPanel();
        });
        centerControlsContainer.appendChild(musicButton);
        
        // 创建时间文本
        currentTimeText = document.createElement('div');
        currentTimeText.innerHTML = '🕒 <span id="time-display"></span>';
        rightInfoContainer.appendChild(currentTimeText);
        
        // 对话文本容器 (already assigned)
        // conversationText = uiDialogPanel;
        
        // Button event listeners are now part of createControlButton
        // Need to re-apply active states if needed elsewhere, or manage via classList
        buttonPlay.addEventListener('click', () => { // Re-add for specific class logic
            if (finished) {
                buttonPlay.innerHTML = "▶ [回放结束]";
                if(buttonPause) buttonPause.style.display = 'none'; // Use style.display
                return;
            }
            buttonPlay.classList.add('active');
            buttonPause.classList.remove('active');
        });

        buttonPause.addEventListener('click', () => { // Re-add for specific class logic
             if (finished) return;
            buttonPlay.classList.remove('active');
            buttonPause.classList.add('active');
        });


        // Setup character icon clicks and initial time display
        setupCharacterIconClickEvents();
        updateTimeDisplay();
        
        console.log("UI创建完成 (美化版)");
    }
    
    // 更新UI位置（响应窗口大小变化）
    function updateUIPositions() {
        const uiBottomPanel = document.getElementById('ui-bottom-panel');
        if (!uiBottomPanel) return;
        
        // 根据屏幕宽度调整按钮样式
        const isMobile = window.innerWidth < 768;
        const buttons = uiBottomPanel.querySelectorAll('button');
        
        buttons.forEach(button => {
            if (button) {
                Object.assign(button.style, {
                    minWidth: isMobile ? '60px' : '80px',
                    fontSize: isMobile ? '12px' : '14px',
                    padding: isMobile ? '3px 8px' : '5px 10px'
                });
            }
        });
    }
    
    // 角色图标点击事件设置
    function setupCharacterIconClickEvents() {
        for (let p in persona_names) {
            const iconTrigger = document.getElementById(`on_screen_det_trigger-${p}`);
            if (iconTrigger) {
                iconTrigger.addEventListener('click', function() {
                    // 特殊处理"实验者"角色（可能是玩家角色）
                    if (p === '实验者') {
                        // 如果实验者是玩家角色，则切换到玩家位置
                        if (player) {
                            // 检查是否已经锁定了该角色
                            if (currentLockedCharacter === player && isCharacterLocked) {
                                // 如果已锁定，则解除锁定
                                unlockCharacter();
                                console.log("解除玩家锁定");
                                return;
                            }
                            
                            // 锁定玩家
                            lockCharacter(player, '实验者');
                            console.log(`视图已锁定到玩家角色, 位置: (${player.x}, ${player.y})`);
                            return;
                        }
                    }
                    
                    // 查找对应NPC对象
                    const npc = personas[p];
                    if (npc) {
                        // 检查是否已经锁定了该NPC
                        if (currentLockedCharacter === npc && isCharacterLocked) {
                            // 如果已锁定，则解除锁定
                            unlockCharacter();
                            console.log(`解除角色锁定: ${p}`);
                            return;
                        }
                        
                        // 锁定该NPC
                        lockCharacter(npc, p);
                        console.log(`视图已锁定到角色: ${p}, 位置: (${npc.x}, ${npc.y})`);
                    } else {
                        console.warn(`找不到角色: ${p}`);
                    }
                });
                console.log(`已为角色 ${p} 添加点击事件`);
            }
        }
    }
    
    // 锁定角色
    function lockCharacter(character, characterName) {
        currentLockedCharacter = character;
        isCharacterLocked = true;

        const startZoom = app.stage.scale.x;
        // 依据性能模式设置较保守的缩放，避免低分辨率下过度放大导致视觉偏移
        const perf = (typeof getPerformanceConfig === 'function') ? getPerformanceConfig(performanceMode) : { };
        const baseOut = 0.15, baseIn = 0.5;
        const targetZoom1 = Math.max(0.1, baseOut * (perf.resolution ? Math.max(0.75, Math.min(1.25, perf.resolution)) : 1));
        const targetZoom2 = Math.max(0.2, baseIn * (perf.resolution ? Math.max(0.75, Math.min(1.25, perf.resolution)) : 1));
        
        const zoomOutDuration = 300; // 0.3 seconds to zoom out to 0.1
        const pauseDuration = 150;   // 0.15 seconds pause
        const zoomInDuration = 300;  // 0.3 seconds to zoom in to 0.5
        const totalDuration = zoomOutDuration + pauseDuration + zoomInDuration;

        const startPanX = app.stage.pivot.x;
        const startPanY = app.stage.pivot.y;
        const endPanX = character.x;
        const endPanY = character.y;

        const startTime = performance.now();

        function animationStep(currentTime) {
            const elapsedTime = currentTime - startTime;
            
            // Pan animation (occurs over totalDuration) — 以角色的可视中心居中
            let panProgress = Math.min(elapsedTime / totalDuration, 1);
            panProgress = easeOutQuint(panProgress); // Apply easing to overall pan progress
            const newX = startPanX + (endPanX - startPanX) * panProgress;
            const newY = startPanY + (endPanY - startPanY) * panProgress;
            app.stage.pivot.x = newX;
            app.stage.pivot.y = newY;

            // Zoom animation (three phases: zoom-out, pause, zoom-in)
            let newZoom;

            if (elapsedTime <= zoomOutDuration) {
                // Phase 1: Zoom out from startZoom to targetZoom1
                let phaseProgress = Math.min(elapsedTime / zoomOutDuration, 1);
                phaseProgress = easeOutQuint(phaseProgress);
                newZoom = startZoom + (targetZoom1 - startZoom) * phaseProgress;
            } else if (elapsedTime <= zoomOutDuration + pauseDuration) {
                // Phase 2: Pause at targetZoom1
                newZoom = targetZoom1;
            } else {
                // Phase 3: Zoom in from targetZoom1 to targetZoom2
                let phaseElapsedTime = elapsedTime - (zoomOutDuration + pauseDuration);
                let phaseProgress = Math.min(phaseElapsedTime / zoomInDuration, 1);
                phaseProgress = easeOutQuint(phaseProgress);
                newZoom = targetZoom1 + (targetZoom2 - targetZoom1) * phaseProgress;
            }
            applyHighQualityZoom(newZoom);

            if (elapsedTime < totalDuration) {
                requestAnimationFrame(animationStep);
            } else {
                // Ensure final values are set
                app.stage.pivot.x = endPanX;
                app.stage.pivot.y = endPanY;
                applyHighQualityZoom(targetZoom2);

                if (characterName === '实验者' && character === player) {
                    highlightPlayer();
                } else {
                    highlightCharacter(characterName);
                }
                updateCurrentCharacterDisplay(characterName + " (已锁定)");
            }
        }
        requestAnimationFrame(animationStep);
    }
    
    // 解除锁定
    function unlockCharacter() {
        isCharacterLocked = false;

        const currentZoom = app.stage.scale.x;
        const targetZoom = (function() {
            try {
                if (app && app.screen && app.loader && app.loader.resources && app.loader.resources.map && app.loader.resources.map.data) {
                    const mapData = app.loader.resources.map.data;
                    if (mapData.width && mapData.height && mapData.tilewidth && mapData.tileheight) {
                        const mapPixelWidth = mapData.width * mapData.tilewidth;
                        const mapPixelHeight = mapData.height * mapData.tileheight;
                        const fitX = app.screen.width / mapPixelWidth;
                        const fitY = app.screen.height / mapPixelHeight;
                        // 留少量边距，避免刚好贴边
                        let fitZoom = Math.min(fitX, fitY) * 0.98;
                        // 合理约束范围
                        fitZoom = Math.max(0.05, Math.min(1, fitZoom));
                        return fitZoom;
                    }
                }
            } catch (e) {
                console.warn('计算全图缩放失败，回退到默认缩放:', e);
            }
            return 0.1; // 回退
        })();
        const duration = 300; // 0.3 seconds

        // --- Pan Logic (runs concurrently with zoom) ---
        if (app.loader.resources.map && app.loader.resources.map.data) {
            const mapData = app.loader.resources.map.data;
            if (mapData.width && mapData.height && mapData.tilewidth && mapData.tileheight) {
                const mapPixelWidth = mapData.width * mapData.tilewidth;
                const mapPixelHeight = mapData.height * mapData.tileheight;
                const mapCenterX = mapPixelWidth / 2;
                const mapCenterY = mapPixelHeight / 2;

                const currentPanX = app.stage.pivot.x;
                const currentPanY = app.stage.pivot.y;
                // Using the same duration as zoom for a synchronized effect
                animatePan(currentPanX, currentPanY, mapCenterX, mapCenterY, duration); 
            } else {
                console.warn("Cannot pan to map center: map data is missing width, height, tilewidth, or tileheight properties.");
            }
        } else {
            console.warn("Cannot pan to map center: app.loader.resources.map.data not available.");
        }

        // --- Zoom Logic ---
        // The original callback content (highlight removal, display update, currentLockedCharacter = null) remains in the zoom's callback.
        animateZoom(currentZoom, targetZoom, duration, () => {
            if (currentLockedCharacter === player) {
                if (player.highlightEffect) {
                    player.removeChild(player.highlightEffect);
                    player.highlightEffect = null;
                }
            } else {
                for (let name in personas) {
                    const npc = personas[name];
                    if (npc && npc.highlightEffect) {
                        npc.removeChild(npc.highlightEffect);
                        npc.highlightEffect = null;
                    }
                }
            }

            let currentCharacterDisplay = document.getElementById('current-character-display');
            if (currentCharacterDisplay) {
                currentCharacterDisplay.textContent = "无锁定角色";
                currentCharacterDisplay.style.backgroundColor = '#e74c3c'; // 红色
                setTimeout(() => {
                    currentCharacterDisplay.style.backgroundColor = 'rgba(0,0,0,0.5)';
                }, 500);
            }
            currentLockedCharacter = null;
        });
    }
    
    // 缓动函数 - easeOutQuint
    function easeOutQuint(x) {
        return 1 - Math.pow(1 - x, 5);
    }

    // 动画缩放函数
    function animateZoom(startZoom, endZoom, duration, callback) {
        const startTime = performance.now();

        function frame(currentTime) {
            const elapsedTime = currentTime - startTime;
            let progress = Math.min(elapsedTime / duration, 1);
            progress = easeOutQuint(progress); // 应用缓动函数
            const newZoom = startZoom + (endZoom - startZoom) * progress;
            applyHighQualityZoom(newZoom);

            if (elapsedTime < duration) { // 确保动画在持续时间内运行
                requestAnimationFrame(frame);
            } else {
                applyHighQualityZoom(endZoom); // 确保最终值为目标值
                if (callback) callback();
            }
        }
        requestAnimationFrame(frame);
    }

    // 将视图中心移动到指定角色位置 (瞬间移动，现在主要由 animatePan 处理平滑移动)
    function centerViewOnCharacter(character) {
        app.stage.pivot.x = character.x;
        app.stage.pivot.y = character.y;
    }

    // 平滑移动镜头函数
    function animatePan(startX, startY, endX, endY, duration, callback) {
        const startTime = performance.now();

        function frame(currentTime) {
            const elapsedTime = currentTime - startTime;
            let progress = Math.min(elapsedTime / duration, 1);
            progress = easeOutQuint(progress); // 应用缓动函数
            
            const newX = startX + (endX - startX) * progress;
            const newY = startY + (endY - startY) * progress;
            
            app.stage.pivot.x = newX;
            app.stage.pivot.y = newY;

            if (elapsedTime < duration) { // 确保动画在持续时间内运行
                requestAnimationFrame(frame);
            } else {
                app.stage.pivot.x = endX; // 确保最终值为目标值
                app.stage.pivot.y = endY;
                if (callback) callback();
            }
        }
        requestAnimationFrame(frame);
    }
    
    // 更新当前跟随的角色显示
    function updateCurrentCharacterDisplay(characterName) {
        // 获取底部面板
        const uiBottomPanel = document.getElementById('ui-bottom-panel');
        if (!uiBottomPanel) return;
        
        // 查找或创建当前角色显示元素
        let currentCharacterDisplay = document.getElementById('current-character-display');
        if (!currentCharacterDisplay) {
            currentCharacterDisplay = document.createElement('div');
            currentCharacterDisplay.id = 'current-character-display';
            currentCharacterDisplay.style.marginLeft = '20px';
            currentCharacterDisplay.style.fontSize = '18px';
            currentCharacterDisplay.style.fontWeight = 'bold';
            currentCharacterDisplay.style.color = 'white';
            currentCharacterDisplay.style.backgroundColor = 'rgba(0,0,0,0.5)';
            currentCharacterDisplay.style.padding = '5px 10px';
            currentCharacterDisplay.style.borderRadius = '5px';
            uiBottomPanel.appendChild(currentCharacterDisplay);
        }
        
        // 更新当前角色名称
        currentCharacterDisplay.textContent = `当前跟随: ${characterName}`;
        
        // 添加一个短暂的高亮效果
        currentCharacterDisplay.style.backgroundColor = '#3498db';
        setTimeout(() => {
            currentCharacterDisplay.style.backgroundColor = 'rgba(0,0,0,0.5)';
        }, 500);
    }
    
    // 高亮显示玩家
    function highlightPlayer() {
        // 重置所有NPC高亮
        for (let p in personas) {
            const npc = personas[p];
            if (npc && npc.highlightEffect) {
                npc.removeChild(npc.highlightEffect);
                npc.highlightEffect = null;
            }
        }
        
        // 移除玩家已有的高亮效果
        if (player.highlightEffect) {
            player.removeChild(player.highlightEffect);
            player.highlightEffect = null;
        }
        
        // 保留玩家选中状态，但不添加视觉效果
        player.highlightEffect = null;
    }
    
    // 高亮显示角色
    function highlightCharacter(characterName) {
        // 重置所有NPC高亮
        for (let p in personas) {
            const npc = personas[p];
            if (npc && npc.highlightEffect) {
                npc.removeChild(npc.highlightEffect);
                npc.highlightEffect = null;
            }
        }
        
        // 清除玩家高亮(如果存在)
        if (player && player.highlightEffect) {
            player.removeChild(player.highlightEffect);
            player.highlightEffect = null;
        }
        
        // 高亮当前选中的NPC
        const selectedNpc = personas[characterName];
        if (selectedNpc) {
            // 保留当前选中的NPC状态，但不添加视觉效果
            selectedNpc.highlightEffect = null;
        }
    }
    
    // 显示或隐藏所有碰撞框
    function showAllCollisionBoxes(show) {
        // 显示/隐藏玩家碰撞框
        if (player && player.collisionBox) {
            player.collisionBox.visible = show;
            // 确保文本标签也更新可见性
            if (player.collisionBox.children && player.collisionBox.children[0] && player.collisionBox.children[0] instanceof PIXI.Text) {
                player.collisionBox.children[0].visible = show;
            }
            if (player.sortChildren) player.sortChildren();
        }
        
        // 显示/隐藏所有NPC的碰撞框
        for (let npcName in personas) {
            const npc = personas[npcName];
            if (npc && npc.collisionBox) {
                npc.collisionBox.visible = show;
                // 确保文本标签也更新可见性
                if (npc.collisionBox.children && npc.collisionBox.children[0] && npc.collisionBox.children[0] instanceof PIXI.Text) {
                    npc.collisionBox.children[0].visible = show;
                }
                if (npc.sortChildren) npc.sortChildren();
            }
        }
        
        // console.log(`All collision boxes visibility set to: ${show}`);
    }

    // 键盘控制 - 增强版本，支持快捷键
    function setupKeyboardControls() {
        window.addEventListener('keydown', (e) => {
            keyboard[e.key] = true;
            
            // 处理对话气泡切换快捷键 (支持自定义按键)
            if (e.key.toLowerCase() === dialogBubbleToggleKey.toLowerCase() && !isDialogBubbleKeyPressed) {
                e.preventDefault();
                isDialogBubbleKeyPressed = true;
                toggleDialogBubbles();
            }
            
            // 添加快捷键支持
            if (e.ctrlKey || e.metaKey) {
                switch(e.key.toLowerCase()) {
                    case ' ': // Ctrl+Space 暂停/运行
                        e.preventDefault();
                        if (finished) return;
                        if (paused) {
                            buttonPlay.click();
                        } else {
                            buttonPause.click();
                        }
                        break;
                    case 'd': // Ctrl+D 显示/隐藏对话面板
                        e.preventDefault();
                        if (buttonShowConversation.style.display === 'none') {
                            buttonHideConversation.click();
                        } else {
                            buttonShowConversation.click();
                        }
                        break;
                    case 's': // Ctrl+S 打开设置
                        e.preventDefault();
                        toggleSettingsWindow();
                        break;
                    case 'w': // Ctrl+W 打开外星代码面板
                        e.preventDefault();
                        toggleWebSimPanel();
                        break;
                }
            }
            
            // ESC键隐藏浮动窗口
            if (e.key === 'Escape') {
                if (settingsWindow) {
                    toggleSettingsWindow();
                }
                if (floatingClockWindow) {
                    toggleFloatingClock();
                }
                if (webSimPanel) {
                    toggleWebSimPanel();
                }
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keyboard[e.key] = false;
            
            // 重置对话气泡按键状态
            if (e.key.toLowerCase() === dialogBubbleToggleKey.toLowerCase()) {
                isDialogBubbleKeyPressed = false;
            }
        });
        
        // 显示快捷键提示
        showSystemMessage(`快捷键: Ctrl+Space(运行/暂停) Ctrl+D(对话面板) ${dialogBubbleToggleKey.toUpperCase()}键(NPC对话气泡) Ctrl+S(设置) Ctrl+W(外星代码) ESC(关闭窗口)`, 5000);
    }

    // 更新时间显示
    function updateTimeDisplay() {
        const timeDisplay = document.getElementById('time-display');
        if (!timeDisplay) return;
        
        timeDisplay.textContent = start_datetime.toLocaleTimeString("zh-CN", datetime_options);
        
        // 更新浮动时钟
        if (!floatingClockWindow) return;
        
        const clockDate = floatingClockWindow.querySelector('.clock-date');
        const clockDisplay = floatingClockWindow.querySelector('.clock-display');
        if (!clockDate || !clockDisplay) return;
        
        // 格式化日期和时间
        const date = start_datetime;
        const dateStr = `${date.getFullYear()}年${(date.getMonth() + 1).toString().padStart(2, '0')}月${date.getDate().toString().padStart(2, '0')}日 ${['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'][date.getDay()]}`;
        const timeStr = `${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}:${date.getSeconds().toString().padStart(2, '0')}`;
        
        clockDate.textContent = dateStr;
        clockDisplay.textContent = timeStr;
    }
    
    // 添加消息队列系统，用于按顺序显示消息
    let messageQueue = [];
    let isProcessingQueue = false;
    
    // 逐条显示消息的函数
    function processMessageQueue() {
        if (messageQueue.length === 0) {
            isProcessingQueue = false;
            return;
        }
        
        isProcessingQueue = true;
        const messageData = messageQueue.shift();
        
        // 创建并显示消息
        createChatMessage(
            messageData.container, 
            messageData.personaName, 
            messageData.text, 
            messageData.emoji, 
            messageData.timestamp, 
            messageData.autoRemove
        );
        
        // 等待一段时间后显示下一条消息
        setTimeout(() => {
            processMessageQueue();
        }, 2000); // 每条消息显示间隔2000毫秒，使显示更慢
    }
    
    // 添加消息到队列
    function addMessageToQueue(container, personaName, text, emoji = "", timestamp = null, autoRemove = false) {
        messageQueue.push({
            container,
            personaName,
            text,
            emoji,
            timestamp,
            autoRemove
        });
        
        // 如果队列未在处理中，开始处理
        if (!isProcessingQueue) {
            processMessageQueue();
        }
    }
    
    // 更新对话
    function updateDialogues() {
        // 获取当前时间点的对话
        const curr_datetime = new Date(start_datetime.getTime());
        const formatNum = num => num.toString().padStart(2, "0");
        
        const timeKey = `${curr_datetime.getFullYear()}${formatNum(curr_datetime.getMonth() + 1)}${formatNum(curr_datetime.getDate())}-${formatNum(curr_datetime.getHours())}:${formatNum(curr_datetime.getMinutes())}`;
        
        // 生成前后2分钟的时间点
        const timeKeys = [-2, -1, 0, 1, 2].map(offset => {
            const date = new Date(curr_datetime.getTime() + offset * 60000);
            return `${date.getFullYear()}${formatNum(date.getMonth() + 1)}${formatNum(date.getDate())}-${formatNum(date.getHours())}:${formatNum(date.getMinutes())}`;
        });
        
        // 获取对话内容元素
        const dialogContent = document.getElementById('conversation-content');
        const defaultDialogContent = document.getElementById('default-dialog-content');
        if (!dialogContent || !defaultDialogContent) return;
        
        // 确保对话面板可见性
        const uiDialogPanel = document.getElementById('ui-dialog-panel');
        if (uiDialogPanel && buttonHideConversation?.style.display === 'flex') {
            uiDialogPanel.style.display = 'block';
        }
        
        // 记录滚动位置
        const wasAtBottom = (dialogContent.scrollHeight - dialogContent.scrollTop) <= (dialogContent.clientHeight + 50);
        
        // 处理新对话
        let hasNewConversation = false;
        const newMessages = [];
        
        // 检查时间点是否有对话
        for (const timeKey of timeKeys) {
            const conversation = all_movement.conversation?.[timeKey];
            if (!conversation || conversation === "" || dialogHistory[timeKey]) continue;
            
            // 检查对话参与者状态
            const shouldShowDialogue = !Object.entries(personas).some(([name, persona]) => {
                const status = getPersonaStatus(name);
                return status?.action?.includes("睡觉") && 
                       (typeof conversation === 'string' ? 
                           conversation.includes(name + "：") : 
                           conversation[name]);
            });
            
            if (!shouldShowDialogue) continue;
            
            // 创建对话记录
            dialogHistory[timeKey] = {
                conversation: typeof conversation === 'string' ? 
                    parseDialogString(conversation) :
                    Object.entries(conversation)
                        .filter(([key]) => key !== 'emoji')
                        .map(([name, msg]) => ({
                            character: name,
                            message: msg,
                            emoji: conversation.emoji || ""
                        })),
                timestamp: curr_datetime.toLocaleTimeString(),
                date: `${curr_datetime.getFullYear()}-${formatNum(curr_datetime.getMonth() + 1)}-${formatNum(curr_datetime.getDate())}`,
                datetime: curr_datetime,
                displayed: false
            };
            
            // 收集新消息
            newMessages.push(...dialogHistory[timeKey].conversation.map(entry => ({
                conversationKey: timeKey,
                personaName: entry.character,
                message: entry.message,
                emoji: entry.emoji || "",
                timestamp: curr_datetime
            })));
            
            // 更新NPC头顶气泡
            updateNPCBubbles(dialogHistory[timeKey].conversation);
            hasNewConversation = true;
        }
        
        // 显示对话内容
        if (Object.keys(dialogHistory).length > 0) {
            dialogContent.style.display = 'flex';
            defaultDialogContent.style.display = 'none';
            
            // 初始化日期分隔线
            if (dialogContent.children.length === 0) {
                const dates = [...new Set(Object.values(dialogHistory).map(record => record.date))].sort();
                dates.forEach(date => {
                    const separator = createDateSeparator(date);
                    dialogContent.appendChild(separator);
                });
            }
            
            // 添加新消息到队列
            if (newMessages.length > 0) {
                newMessages.forEach(msg => {
                    addMessageToQueue(
                        dialogContent,
                        msg.personaName,
                        msg.message,
                        msg.emoji,
                        msg.timestamp
                    );
                });
            }
        } else {
            dialogContent.style.display = 'none';
            defaultDialogContent.style.display = 'block';
        }
    }
    
    // 创建日期分隔线
    function createDateSeparator(date) {
        const separator = document.createElement('div');
        separator.className = 'date-separator';
        Object.assign(separator.style, {
            textAlign: 'center',
            margin: '20px 0',
            color: '#999',
            fontSize: '12px',
            position: 'relative'
        });
        
        const line = document.createElement('div');
        Object.assign(line.style, {
            position: 'absolute',
            top: '50%',
            left: '0',
            right: '0',
            height: '1px',
            backgroundColor: '#ddd',
            zIndex: '1'
        });
        
        const text = document.createElement('span');
        text.textContent = formatDate(date);
        Object.assign(text.style, {
            backgroundColor: '#f2f2f2',
            padding: '0 10px',
            position: 'relative',
            zIndex: '2'
        });
        
        separator.appendChild(line);
        separator.appendChild(text);
        return separator;
    }
    
    // 解析对话字符串，识别格式为"\n\n角色名：对话内容"的文本
    function parseDialogString(dialogText) {
        if (!dialogText || typeof dialogText !== 'string') {
            return [];
        }
        
        console.log("解析原始对话文本...");
        
        // 尝试提取地点信息
        let location = "";
        const locationMatch = dialogText.match(/地点：([^\n]+)/);
        if (locationMatch) {
            location = locationMatch[1];
            console.log(`提取到地点信息: ${location}`);
            // 从对话文本中移除地点信息，以免被当作对话内容
            dialogText = dialogText.replace(/地点：([^\n]+)/, "");
        }
        
        // 分割对话内容 - 改进的解析逻辑
        // 先按换行符分割成行
        const lines = dialogText.split('\n').filter(line => line.trim() !== '');
        const dialogEntries = [];
        
        // 遍历每一行，提取角色名和对话内容
        lines.forEach(line => {
            // 使用冒号来分割角色名和对话内容
            const colonIndex = line.indexOf('：');
            if (colonIndex > 0) {
                const character = line.substring(0, colonIndex).trim();
                const message = line.substring(colonIndex + 1).trim();
                
                if (character && message) {
                    console.log(`解析到对话: 角色=${character}, 消息=${message.substring(0, 30)}...`);
                    
                    
                    // 添加到结果数组
                    dialogEntries.push({
                        character: character,
                        message: message,
                        emoji: "" // 可以在这里添加表情逻辑
                    });
                }
            } else if (line.trim() !== '') {
                // 对于没有冒号的行，尝试作为系统消息或者追加到上一条消息
                if (dialogEntries.length > 0 && !line.match(/^[^\s:：]{1,20}[:：]/)) {
                    // 追加到上一条消息
                    const lastEntry = dialogEntries[dialogEntries.length - 1];
                    lastEntry.message += '\n' + line.trim();
                    console.log(`追加到上一条消息: ${lastEntry.message.substring(0, 30)}...`);
                } else {
                    // 作为系统消息
                    console.log(`创建系统消息: ${line.substring(0, 30)}...`);
                    dialogEntries.push({
                        character: "系统",
                        message: line.trim(),
                        emoji: "ℹ️"
                    });
                }
            }
        });
        
        // 如果提取到了地点信息且有对话条目，添加地点信息作为系统消息（不自动消失）
        if (location && location.trim() !== '') {
            // 格式化地点信息并添加到对话条目的开头
            dialogEntries.unshift({
                character: "系统",
                message: `当前地点: ${location}`,
                emoji: ""
            });
        }
        
        console.log(`解析完成，共提取到 ${dialogEntries.length} 条对话`);
        return dialogEntries;
    }
    
    // 格式化日期函数
    function formatDate(dateStr) {
        const [year, month, day] = dateStr.split('-');
        return `${year}年${parseInt(month)}月${parseInt(day)}日`;
    }
    
    // 初始化对话面板
    function initDialogPanel() {
        const uiDialogPanel = document.getElementById('ui-dialog-panel');
        if (uiDialogPanel) {
            // 设置面板样式
            uiDialogPanel.style.maxHeight = '1200px'; // 增加高度以显示更多对话记录
            uiDialogPanel.style.overflowY = 'auto';
            uiDialogPanel.style.scrollBehavior = 'smooth';
            
            // 获取对话内容元素
            const dialogContent = document.getElementById('conversation-content');
            if (dialogContent) {
                // 添加滚动监听器，检测用户是否手动滚动
                dialogContent.addEventListener('scroll', function() {
                    let previousAutoScrollEnabledState = autoScrollEnabled; // 存储先前的状态
                    // 检查是否滚动到底部附近
                    const isNearBottom = (dialogContent.scrollHeight - dialogContent.scrollTop) <= (dialogContent.clientHeight + 50);
                    
                    // 更新自动滚动状态 - 当用户手动向上滚动时禁用自动滚动，滚到底部时重新启用
                    autoScrollEnabled = isNearBottom;
                    
                    // 调试输出
                    if (previousAutoScrollEnabledState !== autoScrollEnabled) { // 与先前的状态比较
                        console.log(`自动滚动状态: ${autoScrollEnabled ? '启用' : '禁用'}`);
                    }
                });
                
                // 添加自动滚动开关到对话面板
                addAutoScrollToggle(uiDialogPanel);
            }
            
            // 其他样式通过addWeChatStyleCSS函数添加
            console.log("对话面板初始化完成");

            // 确保 uiDialogPanel 可以作为绝对定位子元素的容器
            uiDialogPanel.style.position = 'relative';

            // 创建"滚动到最新消息"按钮
            const scrollToBottomBtn = document.createElement('button');
            scrollToBottomBtn.innerHTML = '⬇️<span style="font-size:0.8em; margin-left: 4px;">最新</span>';
            scrollToBottomBtn.title = '滚动到最新消息';
            Object.assign(scrollToBottomBtn.style, {
                position: 'absolute',
                bottom: '10px',
                right: '10px',
                zIndex: '1001',
                padding: '6px 10px', // 调整了内边距
                backgroundColor: 'var(--accent-primary)',
                color: 'var(--text-on-accent)',
                border: '1px solid var(--border-color-light)', // 添加了边框
                borderRadius: 'var(--border-radius-md)',
                cursor: 'pointer',
                boxShadow: 'var(--shadow-sm)',
                opacity: '0.85', // 调整了透明度
                transition: 'opacity 0.2s, background-color 0.2s'
            });
            scrollToBottomBtn.addEventListener('mouseover', () => { 
                scrollToBottomBtn.style.opacity = '1';
                scrollToBottomBtn.style.backgroundColor = 'var(--accent-primary-darker, color-mix(in srgb, var(--accent-primary) 85%, black))'; // 假设有这样一个深色变量
            });
            scrollToBottomBtn.addEventListener('mouseout', () => { 
                scrollToBottomBtn.style.opacity = '0.85';
                scrollToBottomBtn.style.backgroundColor = 'var(--accent-primary)';
            });

            scrollToBottomBtn.addEventListener('click', function() {
                autoScrollEnabled = true; // 确保 scrollToLatestMessage 会执行
                scrollToLatestMessage();
                console.log("手动触发滚动到最新消息");
            });

            uiDialogPanel.appendChild(scrollToBottomBtn);

        }
    }
    
    // 更新角色位置和动画
    function updateCharacters() {
        // 玩家移动处理
        const speed = 20;
        let isMoving = false;
        let playerDirection = lastPlayerDirection;
        
        if (keyboard["ArrowLeft"]) {
            player.x -= speed;
            playerDirection = 'left';
            isMoving = true;
        } else if (keyboard["ArrowRight"]) {
            player.x += speed;
            playerDirection = 'right';
            isMoving = true;
        }
        
        if (keyboard["ArrowUp"]) {
            player.y -= speed;
            if (!isMoving) playerDirection = 'up';
            isMoving = true;
        } else if (keyboard["ArrowDown"]) {
            player.y += speed;
            if (!isMoving) playerDirection = 'down';
            isMoving = true;
        }
        
        if (isMoving) {
            lastPlayerDirection = playerDirection;
            if (player) {
                // 仅当没有角色被锁定时，相机才跟随玩家移动
                if (!isCharacterLocked) {
                    app.stage.pivot.x = player.x;
                    app.stage.pivot.y = player.y;
                }
            }
        }
        
        // 处理角色跟踪功能
        const tempFocusElement = document.getElementById("temp_focus");
        if (tempFocusElement) {
            const curr_focused_persona = tempFocusElement.textContent.trim();
            if (curr_focused_persona !== "") {
                console.log("检测到角色选择:", curr_focused_persona);
                
                // 查找目标角色
                const targetPersona = personas[curr_focused_persona];
                
                if (targetPersona && player && player.body) {
                    console.log("找到目标角色，位置:", targetPersona.x, targetPersona.y);
                    
                    // 将玩家body位置设置到该角色位置（这是关键！）
                    player.body.x = targetPersona.x;
                    player.body.y = targetPersona.y;
                    
                    console.log("角色跟踪设置完成:", curr_focused_persona);
                } else {
                    // 如果没有找到指定角色，尝试使用玩家角色
                    if (personas['玩家'] && player && player.body) {
                        console.log("未找到指定角色，使用玩家角色作为默认");
                        player.body.x = personas['玩家'].x;
                        player.body.y = personas['玩家'].y;
                    } else {
                        console.warn("未找到目标角色或玩家body:", curr_focused_persona, "可用角色:", Object.keys(personas));
                        // 只在第一次警告时显示，避免重复日志
                        if (!window.characterSelectionWarningShown) {
                            showSystemMessage(`角色 '${curr_focused_persona}' 不存在，请检查角色数据`);
                            window.characterSelectionWarningShown = true;
                        }
                    }
                }
                
                // 清空temp_focus
                tempFocusElement.innerHTML = "";
            }
        }
        
        // NPC移动逻辑
        for (const curr_persona_name of Object.keys(personas)) {
            const curr_persona = personas[curr_persona_name];
            if (!curr_persona) continue;

            if (!(step in all_movement)) {
                finished = true;
                if (buttonPlay) buttonPlay.textContent = "▶ [回放结束]";
                if (buttonPause) buttonPause.visible = false;
                break;
            }

            const movement_data = all_movement[step][curr_persona_name] || 
                                all_movement[step][curr_persona_name.replace("_", " ")];
            
            if (!movement_data) continue;

            // 处理目标位置设置和动作更新
            if (execute_count === execute_count_max) {
                const [curr_x, curr_y] = movement_data.movement;
                movement_target[curr_persona_name] = [
                    curr_x * tile_width + tile_width / 2 - 10,
                    curr_y * tile_width + tile_width / 2
                ];

                const action = movement_data.action;
                const act = action.length > 25 ? action.substring(0, 20)+"..." : action;
                updateActionBubble(curr_persona_name, act, movement_data.emoji || "");
                
                // 更新UI状态
                try {
                    const elements = {
                        desc: document.getElementById(`agent_desc__${curr_persona_name}`),
                        action: document.getElementById(`current_action__${curr_persona_name}`),
                        address: document.getElementById(`target_address__${curr_persona_name}`)
                    };
                    
                    if (elements.desc) {
                        elements.desc.innerHTML = all_movement.description[curr_persona_name].currently;
                    }
                    if (elements.action) {
                        elements.action.innerHTML = action;
                    }
                    if (elements.address) {
                        elements.address.innerHTML = movement_data.location;
                    }
                } catch (e) {
                    console.warn("更新状态显示失败:", e);
                }
            }

            if (execute_count > 0 && movement_target[curr_persona_name]) {
                const [targetX, targetY] = movement_target[curr_persona_name];
                if (targetX === undefined || targetY === undefined) continue;

                const POSITION_THRESHOLD = 2;
                const hasReachedX = Math.abs(curr_persona.x - targetX) <= POSITION_THRESHOLD;
                const hasReachedY = Math.abs(curr_persona.y - targetY) <= POSITION_THRESHOLD;
                
                if (!hasReachedX || !hasReachedY) {
                    // 更新位置
                    const newX = !hasReachedX 
                        ? curr_persona.x + (curr_persona.x < targetX ? movement_speed : -movement_speed)
                        : curr_persona.x;
                        
                    const newY = !hasReachedX && hasReachedY
                        ? curr_persona.y
                        : curr_persona.y + (curr_persona.y < targetY ? movement_speed : -movement_speed);
                    
                    // 更新方向
                    if (!hasReachedX) {
                        pre_anims_direction_dict[curr_persona_name] = curr_persona.x < targetX ? "r" : "l";
                    } else {
                        pre_anims_direction_dict[curr_persona_name] = curr_persona.y < targetY ? "d" : "u";
                    }
                    
                    // 应用新位置
                    curr_persona.x = newX;
                    curr_persona.y = newY;
                    
                    // 更新气泡
                    const bubble = pronunciatios[curr_persona_name];
                    if (bubble?.container) {
                        updateBubblePosition(curr_persona_name);
                        bubble.container.visible = true;
                    }
                } else {
                    // 已到达目标位置
                    curr_persona.x = targetX;
                    curr_persona.y = targetY;
                }
            }
        }

        // 更新执行状态
        if (execute_count === 0) {
            // 更新所有NPC到目标位置
            Object.entries(personas).forEach(([name, persona]) => {
                const target = movement_target[name];
                if (target?.[0] !== undefined && target?.[1] !== undefined) {
                    persona.x = target[0];
                    persona.y = target[1];
                }
            });
            
            execute_count = execute_count_max + 1;
            step += 1;
            start_datetime = new Date(start_datetime.getTime() + step_size);
            // 更新网页模拟面板中的时间显示和文件可见性
            if (webSimPanel && webSimPanel.style.display !== 'none') {
                // 更新时间显示
                const timeInfo = webSimPanel.querySelector('.window-content > div:first-child');
                if (timeInfo) {
                    const currentTime = new Date(start_datetime);
                    const timeString = `${currentTime.getFullYear()}-${(currentTime.getMonth()+1).toString().padStart(2,'0')}-${currentTime.getDate().toString().padStart(2,'0')} ${currentTime.getHours().toString().padStart(2,'0')}:${currentTime.getMinutes().toString().padStart(2,'0')}`;
                    timeInfo.innerHTML = `<strong>当前模拟时间:</strong><br>${timeString}`;
                }
                
                // 更新文件可见性
                const listContainer = webSimPanel.querySelector('#web-sim-list-container');
                if (listContainer) {
                    const currentTimeMs = start_datetime.getTime();
                    const fileItems = listContainer.querySelectorAll('li');
                    fileItems.forEach(li => {
                        const fileName = li.querySelector('div > div').textContent;
                        const fileTime = parseHtmlFileTime(fileName);
                        if (fileTime) {
                            li.style.display = fileTime.getTime() <= currentTimeMs ? 'block' : 'none';
                        }
                    });
                }
            }
            updateTimeDisplay();
        }

        execute_count -= 1;
    }

    // 游戏主循环
    function gameLoop(delta) {
        if (finished || paused) return;
        
        // 更新角色
        updateCharacters();
        
        // 更新视图跟随
        if (isCharacterLocked && currentLockedCharacter) {
            centerViewOnCharacter(currentLockedCharacter);
        }
        
        // 根据当前游戏时间更新角色头顶图片
        const currentGameTime = new Date(start_datetime);
        for (const personaName in personas) {
            updateCharacterImage(personaName, currentGameTime);
        }
        
        // 性能优化：计算帧率并根据需要跳过复杂更新
        frameSkipCounter = (frameSkipCounter + 1) % (frameSkipThreshold + 1);
        const isFullFrame = frameSkipCounter === 0;
        
        // 执行不同频率的更新
        if (isFullFrame) {
            updateDialogues();
            updateCollisionBoxes();
            updateBubbleVisibility();
            
            // 低频率执行UI更新
            if (frameSkipCounter % (frameSkipThreshold * 2) === 0) {
                forceUpdateUI();
            }
            
            // 性能优化：定期清理内存
            const currentTime = Date.now();
            if (currentTime - lastMemoryCleanup > memoryCleanupInterval) {
                performMemoryCleanup();
                lastMemoryCleanup = currentTime;
            }
        }
        
        // 更新所有角色动画
        updateAllCharacterAnimations();
        
        // 清理标记为要删除的气泡计时器
        if (bubbleTimersToRemove.length > 0) {
            bubbleTimersToRemove.forEach(timerId => {
                if (bubbleTimers[timerId]) {
                    clearTimeout(bubbleTimers[timerId]);
                    delete bubbleTimers[timerId];
                }
            });
            bubbleTimersToRemove = [];
        }
    }
    
    // 添加内存清理函数
    function performMemoryCleanup() {
        // 清理过期的气泡计时器
        Object.entries(bubbleTimers).forEach(([timerId, timerInfo]) => {
            if (timerInfo?.expirationTime && Date.now() > timerInfo.expirationTime) {
                clearTimeout(timerInfo.timer);
                delete bubbleTimers[timerId];
            }
        });
        
        // 限制对话队列大小
        Object.entries(dialogQueues).forEach(([personaName, queue]) => {
            if (queue?.length > 10) {
                dialogQueues[personaName] = queue.slice(-10);
            }
        });
        
        // 清理打字效果状态
        Object.entries(typingEffects).forEach(([personaName, effect]) => {
            if (!personas[personaName] || !pronunciatios[personaName]) {
                clearInterval(effect?.interval);
                delete typingEffects[personaName];
            }
        });
        
        // 限制对话历史记录大小
        const historyKeys = Object.keys(dialogHistory);
        if (historyKeys.length > maxDialogHistorySize) {
            const keysToRemove = historyKeys.slice(0, Math.floor(historyKeys.length * 0.2));
            keysToRemove.forEach(key => delete dialogHistory[key]);
        }
        
        // 清理DOM中过多的消息
        const dialogContainer = document.getElementById('conversation-content');
        if (dialogContainer) {
            const messages = dialogContainer.querySelectorAll('.chat-message');
            if (messages.length > 50) {
                Array.from(messages)
                    .slice(0, messages.length - 50)
                    .forEach(msg => msg.remove());
            }
        }
        
        // 清理PIXI纹理缓存
        if (PIXI.utils.TextureCache) {
            Object.keys(PIXI.utils.TextureCache)
                .filter(key => key.includes('TEMP_') || key.includes('_temp'))
                .forEach(key => {
                    PIXI.utils.TextureCache[key].destroy(true);
                    delete PIXI.utils.TextureCache[key];
                });
        }
    }

    // 确保气泡正确显示 - 优化版本
    function updateBubbleVisibility() {
        Object.entries(pronunciatios).forEach(([personaName, bubble]) => {
            if (bubble?.container?.visible) {
                bubble.container.zIndex = 1000;
                updateBubblePosition(personaName);
                personas[personaName]?.sortChildren();
            }
        });
    }
    
    // 强制更新UI位置和可见性 - 优化版本
    function forceUpdateUI() {
        updateTimeDisplay();
        updateUIPositions();
    }
    
    // 更新所有角色的动画
    function updateAllCharacterAnimations() {
        // 更新玩家动画
        if (player && player.updateAnimation) {
            // 检查玩家是否在移动
            const isMoving = keyboard["ArrowLeft"] || keyboard["ArrowRight"] || 
                           keyboard["ArrowUp"] || keyboard["ArrowDown"];
            player.updateAnimation(lastPlayerDirection, isMoving);
        }
        
        // 更新所有NPC的动画
        for (let npcName in personas) {
            const npc = personas[npcName];

            // 增强检查：确保npc对象有效并且拥有必要的属性/方法
            if (!npc || typeof npc.updateAnimation !== 'function' || typeof npc.x === 'undefined' || typeof npc.y === 'undefined') {
                console.warn(`[updateCharacters] Invalid or incomplete NPC object for '${npcName}'. Skipping update. Personas object for this NPC:`, npc);
                console.log(`[updateCharacters] Problematic npcName: ${npcName}. Available character names in personas: ${Object.keys(personas).join(', ')}`);
                // 如果 npc 存在但缺少关键部分，可以进一步打印 npc 的结构
                if (npc) {
                    console.log(`[updateCharacters] Details of problematic NPC object '${npcName}':`, JSON.stringify(npc, Object.getOwnPropertyNames(npc)));
                }
                continue; // 跳过此NPC的更新
            }
            
            // if (npc && npc.updateAnimation) { // 此条件因上面的检查而变得多余
            let direction = 'down';
            let isMoving = false;
                
                // 获取NPC的当前移动状态
                if (movement_target[npcName]) {
                    const targetX = movement_target[npcName][0];
                    const targetY = movement_target[npcName][1];
                    
                    // 计算到目标的距离
                    const dx = targetX - npc.x;
                    const dy = targetY - npc.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // 判断是否正在移动 (增大判断阈值，确保动画有机会播放)
                    isMoving = distance > 3;
                    
                    // 根据移动方向确定动画方向
                    if (isMoving) {
                        // 与玩家角色一致的动画方向处理
                        if (Math.abs(dx) > Math.abs(dy)) {
                            // 水平移动为主
                            direction = dx > 0 ? 'right' : 'left';
                        } else {
                            // 垂直移动为主
                            direction = dy > 0 ? 'down' : 'up';
                        }
                        
                        // 记录上一次的动画方向
                        pre_anims_direction_dict[npcName] = direction === 'left' ? "l" : 
                                                          direction === 'right' ? "r" : 
                                                          direction === 'up' ? "u" : "d";
                    } else {
                        // 静止状态，使用上次的方向
                        switch (pre_anims_direction_dict[npcName]) {
                            case "l": direction = 'left'; break;
                            case "r": direction = 'right'; break;
                            case "u": direction = 'up'; break;
                            case "d": direction = 'down'; break;
                            default: direction = 'down'; break;
                        }
                    }
                }
                
                // 更新NPC动画
                npc.updateAnimation(direction, isMoving);
            // }
        }
    }
    
    // 确保碰撞框可见和正确位置
    function updateCollisionBoxes() {
        // 获取当前碰撞框显示状态 (从全局变量获取)
        const showCollisionBoxesGlobal = globalShowCollisionBoxes;
        
        // 更新玩家碰撞框
        if (player && player.collisionBox) {
            player.collisionBox.visible = showCollisionBoxesGlobal;
            if (player.collisionBox.children && player.collisionBox.children[0] && player.collisionBox.children[0] instanceof PIXI.Text) {
                player.collisionBox.children[0].visible = showCollisionBoxesGlobal;
            }
            player.collisionBox.zIndex = 1000;
            if (player.sortChildren) player.sortChildren();
        }
        
        // 更新所有NPC的碰撞框
        for (let npcName in personas) {
            const npc = personas[npcName];
            if (npc && npc.collisionBox) {
                npc.collisionBox.visible = showCollisionBoxesGlobal;
                if (npc.collisionBox.children && npc.collisionBox.children[0] && npc.collisionBox.children[0] instanceof PIXI.Text) {
                    npc.collisionBox.children[0].visible = showCollisionBoxesGlobal;
                }
                npc.collisionBox.zIndex = 1000;
                if (npc.sortChildren) npc.sortChildren();
            }
        }
        
        // 强制整个角色容器排序 (app.stage.children包含mapContainer, characterContainer, imageContainer)
        app.stage.children.forEach(child => {
            if (child && child.sortableChildren) { 
                child.sortChildren();
            }
        });
    }

    // 显示欢迎对话
    function showWelcomeMessages(container) {
        if (!container) {
            console.error("对话容器不存在");
            return;
        }
        
        console.log("跳过显示欢迎对话...");
        
        // 清空容器
        container.innerHTML = '';
        
        // 显示对话内容，隐藏默认内容
        container.style.display = 'flex';
        const defaultContent = document.getElementById('default-dialog-content');
        if (defaultContent) {
            defaultContent.style.display = 'none';
        }
        
        // 不再创建任何欢迎消息
    }

    // 创建聊天消息
    function createChatMessage(container, personaName, text, emoji = "", timestamp = null, autoRemove = false) {
        console.log(`创建消息: ${personaName} -> ${text.substring(0, 30)}...`);
        
        // 如果personaName为空，使用系统作为默认值
        if (!personaName || personaName.trim() === '') {
            personaName = "系统";
        }
        
        // 创建时间戳，如果没有提供则使用当前时间
        const messageTime = timestamp || new Date();
        const timeString = messageTime.getHours().toString().padStart(2, '0') + ':' + 
                          messageTime.getMinutes().toString().padStart(2, '0');
        
        // 检查是否是系统消息
        const isSystem = personaName === "系统";
        
        // 如果不是系统消息，递增消息计数器
        if (!isSystem) {
            messageCounter++;
        }
        
        // 根据消息计数器的奇偶性决定消息位置
        // 奇数(messageCounter % 2 === 1)显示在左边，偶数(messageCounter % 2 === 0)显示在右边
        const isRight = !isSystem && (messageCounter % 2 === 0);
        
        // 检查是否和上一个发言者相同
        const isSameSpeaker = (lastSpeaker === personaName);
        
        // 更新上一个发言者
        lastSpeaker = personaName;
        
        // 创建消息容器
        const messageDiv = document.createElement('div');
        messageDiv.className = 'chat-message';
        messageDiv.style.display = 'flex';
        messageDiv.style.margin = '5px 0';
        messageDiv.style.padding = '5px 10px';
        messageDiv.style.maxWidth = '100%';
        messageDiv.style.position = 'relative';
        messageDiv.style.opacity = '0'; // 开始时透明
        messageDiv.style.transform = 'translateY(20px)'; // 开始时向下偏移
        messageDiv.style.transition = 'opacity 0.5s ease, transform 0.5s ease'; // 添加过渡效果
        
        if (isRight) {
            messageDiv.style.flexDirection = 'row-reverse';
            messageDiv.style.justifyContent = 'flex-start';
        }
        
        if (isSystem) {
            messageDiv.style.justifyContent = 'center';
            messageDiv.style.backgroundColor = 'rgba(230, 230, 230, 0.8)';
            messageDiv.style.borderRadius = '5px';
            messageDiv.style.padding = '5px 10px';
            messageDiv.style.margin = '5px 0';
            messageDiv.style.color = '#000000';
            messageDiv.style.fontSize = '0.9em';
            messageDiv.style.textAlign = 'center';
            messageDiv.style.border = '1px solid #ccc';
            
            const textSpan = document.createElement('span');
            if (emoji && emoji.trim() !== '') {
                textSpan.textContent = `${emoji} ${text}`;
            } else {
                textSpan.textContent = text;
            }
            
            messageDiv.appendChild(textSpan);
            
            const timeStamp = document.createElement('div');
            timeStamp.className = 'message-time';
            timeStamp.textContent = timeString;
            timeStamp.style.fontSize = '0.7em';
            timeStamp.style.color = '#777';
            timeStamp.style.textAlign = 'center';
            timeStamp.style.marginTop = '3px';
            
            messageDiv.appendChild(timeStamp);
            
            container.appendChild(messageDiv);
            
            // 添加动画效果
            setTimeout(() => {
                messageDiv.style.opacity = '1';
                messageDiv.style.transform = 'translateY(0)';
                messageDiv.classList.add('show');
            }, 10);
            
            if (text.includes("欢迎") || 
                text.includes("模拟开始后") || 
                text.includes("点击顶部的角色头像") ||
                text.includes("控制栏的按钮") ||
                text.includes("您好！") ||
                emoji === "👋" || emoji === "😊" || emoji === "🔍" || emoji === "⏯️"
            ) {
                console.log(`检测到介绍消息：${text.substring(0, 20)}...`);
                messageDiv.classList.add('intro-message');
                autoRemove = true;
            }
            
            if (autoRemove) {
                console.log(`设置消息自动移除: ${text.substring(0, 20)}...`);
                messageDiv.dataset.autoRemove = "true";
            }
            
            // 滚动到最新消息 - 关键修改点：仅当 autoScrollEnabled 为 true 时执行
            setTimeout(() => {
                if (autoScrollEnabled) {
                    scrollToLatestMessage();
                }
            }, 10); 
            
            return messageDiv;
        }
        
        // 对于非系统消息，创建类似微信的气泡布局
        
        // 如果与上一条消息发送者相同，则不再显示头像和名称
        if (!isSameSpeaker) {
            // 创建头像容器
            const avatarDiv = document.createElement('div');
            avatarDiv.className = 'chat-avatar';
            avatarDiv.style.flexShrink = '0';
            avatarDiv.style.width = '40px';
            avatarDiv.style.height = '40px';
            avatarDiv.style.borderRadius = '50%';
            avatarDiv.style.overflow = 'hidden';
            avatarDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
            
            // 调整头像边距方向
            if (isRight) {
                avatarDiv.style.marginLeft = '10px';
            } else {
                avatarDiv.style.marginRight = '10px';
            }
            
            // 尝试加载不同格式的头像
            const possiblePaths = [
                `/static/assets/village/agents/${personaName}/portrait.png`,
                `/static/assets/village/agents/${personaName.replace(/\s+/g, '')}/portrait.png`,
                `/static/assets/village/agents/${personaName.toLowerCase()}/portrait.png`,
                `/static/assets/village/agents/${personaName.replace(/\s+/g, '').toLowerCase()}/portrait.png`
            ];
            
            console.log(`尝试加载 ${personaName} 的头像，可能路径:`, possiblePaths);
            
            // 创建图像元素
            const avatarImg = document.createElement('img');
            avatarImg.style.width = '100%';
            avatarImg.style.height = '100%';
            avatarImg.style.objectFit = 'cover';
            
            // 尝试所有可能的路径
            let loadSuccess = false;
            
            // 设置首选路径
            avatarImg.src = possiblePaths[0];
            avatarImg.alt = personaName;
            
            // 处理加载错误
            avatarImg.onerror = function() {
                console.error(`头像加载失败: ${avatarImg.src}`);
                
                // 尝试下一个路径
                const currentIndex = possiblePaths.indexOf(avatarImg.src);
                if (currentIndex < possiblePaths.length - 1) {
                    console.log(`尝试备用路径: ${possiblePaths[currentIndex + 1]}`);
                    avatarImg.src = possiblePaths[currentIndex + 1];
                } else {
                    console.log(`所有头像路径尝试失败，使用字母头像`);
                    
                    // 移除失败的图像
                    if (avatarImg.parentNode) {
                        avatarImg.parentNode.removeChild(avatarImg);
                    }
                    
                    // 创建字母头像
                    const letterAvatar = createLetterAvatar(personaName);
                    avatarDiv.appendChild(letterAvatar);
                }
            };
            
            // 处理加载成功
            avatarImg.onload = function() {
                console.log(`头像加载成功: ${avatarImg.src}`);
                loadSuccess = true;
            };
            
            // 添加图像到头像容器
            avatarDiv.appendChild(avatarImg);
            
            // 创建名称元素
            const nameDiv = document.createElement('div');
            nameDiv.className = 'chat-name';
            nameDiv.style.fontSize = '0.8em';
            nameDiv.style.marginBottom = '2px';
            nameDiv.style.color = '#666';
            nameDiv.textContent = personaName;
            nameDiv.style.textAlign = isRight ? 'right' : 'left';
            
            // 创建头像和名称的列
            const avatarNameCol = document.createElement('div');
            avatarNameCol.className = 'avatar-name-col';
            avatarNameCol.style.display = 'flex';
            avatarNameCol.style.flexDirection = 'column';
            avatarNameCol.style.alignItems = isRight ? 'flex-end' : 'flex-start';
            avatarNameCol.style.width = '40px';
            
            // 在头像下方显示名称
            avatarNameCol.appendChild(avatarDiv);
            avatarNameCol.appendChild(nameDiv);
            
            messageDiv.appendChild(avatarNameCol);
        } else {
            // 为同一发言者的后续消息添加空白占位
            const spacerDiv = document.createElement('div');
            spacerDiv.style.width = '50px'; // 头像+边距的宽度
            spacerDiv.style.flexShrink = '0';
            messageDiv.appendChild(spacerDiv);
        }
        
        // 创建内容容器 (气泡)
        const bubbleDiv = document.createElement('div');
        bubbleDiv.className = 'chat-bubble';
        
        // 自适应气泡设置
        bubbleDiv.style.display = 'inline-block'; // 使气泡宽度自适应内容
        bubbleDiv.style.minWidth = '40px'; // 设置最小宽度
        bubbleDiv.style.maxWidth = 'calc(70% - 20px)'; // 设置最大宽度
        bubbleDiv.style.padding = '8px 12px';
        bubbleDiv.style.position = 'relative';
        bubbleDiv.style.wordBreak = 'break-word';
        bubbleDiv.style.whiteSpace = 'pre-wrap'; // 保留换行和空格
        bubbleDiv.style.boxSizing = 'border-box'; // 确保padding计入总宽度
        
        // 根据是否为右侧消息设置不同的气泡样式
        if (isRight) {
            // 右侧气泡样式
            bubbleDiv.style.backgroundColor = '#FFFFFF';
            bubbleDiv.style.color = '#000000';
            bubbleDiv.style.borderRadius = '8px';
            bubbleDiv.style.marginLeft = '10px';
            bubbleDiv.style.boxShadow = '0 1px 2px rgba(0,0,0,0.1)';
            
            // 添加气泡小尖角
            if (!isSameSpeaker) {
                bubbleDiv.style.borderTopRightRadius = '0';
            }
        } else {
            // 左侧气泡样式
            bubbleDiv.style.backgroundColor = 'rgba(52, 152, 219, 0.8)';
            bubbleDiv.style.color = '#FFFFFF';
            bubbleDiv.style.borderRadius = '8px';
            bubbleDiv.style.marginRight = '10px';
            bubbleDiv.style.paddingBottom = '12px'; // 增加底部行距
            
            // 添加气泡小尖角
            if (!isSameSpeaker) {
                bubbleDiv.style.borderTopLeftRadius = '0';
            }
        }
        
        // 创建消息文本元素
        const textDiv = document.createElement('div');
        textDiv.className = 'chat-text';
        
        // 添加表情符号（如果有）
        if (emoji && emoji.trim() !== '') {
            // 检查是否为对话表情(💬)，如果是则只显示文本内容，完全忽略表情符号
            if (emoji.trim() === '💬') {
                // 删除text开头可能的空格和换行符
                const cleanedText = text.replace(/^[\s\n]+/, '');
                textDiv.textContent = cleanedText; // 不显示💬表情符号
            } else {
                textDiv.textContent = `${emoji} ${text}`;
            }
        } else {
            textDiv.textContent = text;
        }
        
        // 组装内容
        bubbleDiv.appendChild(textDiv);
        
        // 创建时间戳
        const timeStamp = document.createElement('div');
        timeStamp.className = 'message-time';
        timeStamp.textContent = timeString;
        timeStamp.style.fontSize = '0.7em';
        timeStamp.style.color = '#777';
        timeStamp.style.marginTop = '2px';
        timeStamp.style.textAlign = isRight ? 'right' : 'left';
        
        // 气泡容器，用于确保气泡对齐
        const bubbleContainer = document.createElement('div');
        bubbleContainer.style.display = 'flex';
        bubbleContainer.style.flexDirection = 'column';
        bubbleContainer.style.alignItems = isRight ? 'flex-end' : 'flex-start';
        bubbleContainer.style.flex = '1';
        bubbleContainer.appendChild(bubbleDiv);
        bubbleContainer.appendChild(timeStamp);
        
        // 组装消息
        messageDiv.appendChild(bubbleContainer);
        
        // 添加到容器
        container.appendChild(messageDiv);
        
        // 添加动画效果
        setTimeout(() => {
            messageDiv.style.opacity = '1';
            messageDiv.style.transform = 'translateY(0)';
        }, 10);
        
        // 滚动到最新消息 - 关键修改点：仅当 autoScrollEnabled 为 true 时执行
        // 使用一个非常短的延时，以确保DOM更新完成
        setTimeout(() => {
            if (autoScrollEnabled) {
                scrollToLatestMessage();
            }
        }, 10); 
        
        return messageDiv;
    }
    
    // 创建字母头像
    function createLetterAvatar(name) {
        // 创建canvas元素
        const canvas = document.createElement('canvas');
        canvas.width = 40;
        canvas.height = 40;
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        
        // 设置willReadFrequently属性以优化性能
        canvas.willReadFrequently = true;
        
        // 获取2D上下文并设置willReadFrequently
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        if (ctx) {
            ctx.willReadFrequently = true;
        }
        
        // 获取首字母
        let initials = "";
        if (name && name.trim() !== '') {
            // 分割名称并获取每个部分的首字母
            const nameParts = name.trim().split(/\s+/);
            if (nameParts.length === 1) {
                // 只有一个单词，取前两个字母
                initials = nameParts[0].substring(0, 2).toUpperCase();
            } else {
                // 多个单词，取每个单词的首字母
                initials = nameParts.map(part => part.charAt(0).toUpperCase()).join('').substring(0, 2);
            }
        } else {
            initials = "??";
        }
        
        // 根据名称生成背景颜色
        const hue = Math.abs(name.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0) % 360);
        const bgColor = `hsl(${hue}, 70%, 40%)`;
        
        // 绘制背景
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // 设置文本样式
        ctx.fillStyle = 'white';
        ctx.font = 'bold 20px Arial, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // 绘制首字母
        ctx.fillText(initials, canvas.width / 2, canvas.height / 2);
        
        return canvas;
    }

    // 显示系统消息
    function showSystemMessage(message, duration = 3000) {
        // 创建消息元素
        const messageEl = document.createElement('div');
        messageEl.className = 'system-message-popup'; // New class for specific styling
        messageEl.textContent = message;
        
        // Apply styles using CSS variables and improved aesthetics
        Object.assign(messageEl.style, {
            position: 'fixed',
            bottom: '100px', // 调整高度避免遮挡
            left: '50%',
            transform: 'translateX(-50%)',
            backgroundColor: 'linear-gradient(145deg, rgba(26, 26, 26, 0.98), rgba(10, 10, 10, 0.98))',
            color: 'var(--text-primary, #f4e4c1)',
            padding: '15px 25px', // 增加内边距
            borderRadius: 'var(--border-radius-md, 10px)',
            zIndex: '10001',
            boxShadow: 'var(--shadow-lg, 0 8px 32px rgba(212, 175, 55, 0.2))',
            fontSize: '15px',
            fontWeight: '600',
            pointerEvents: 'none',
            opacity: '0',
            transition: 'all 0.3s ease-in-out',
            fontFamily: 'var(--font-family-ui)',
            transform: 'translateX(-50%) translateY(20px)',
            border: '1px solid var(--border-color, #4a3f2a)',
            textShadow: '0 0 5px rgba(212, 175, 55, 0.5)',
            minWidth: '200px',
            textAlign: 'center'
        });
        
        // Add to document
        document.body.appendChild(messageEl);

        // Animate in
        setTimeout(() => {
            messageEl.style.opacity = '1';
            messageEl.style.transform = 'translateX(-50%) translateY(0px)';
        }, 50); // Short delay to ensure transition takes effect
        
        // 定时移除
        setTimeout(() => {
            messageEl.style.opacity = '0';
            messageEl.style.transform = 'translateX(-50%) translateY(10px)';
            setTimeout(() => {
                if (document.body.contains(messageEl)) {
                     document.body.removeChild(messageEl);
                }
            }, 300); // Wait for fade out animation
        }, duration);
    }
    
    // 更新NPC头顶文字框
    function updateNPCBubbles(dialogEntries) {
        try {
            if (dialogEntries && dialogEntries.length > 0) {
                sortDialogueEntries(dialogEntries);
                
                if (!isDialogueGroupPlaying) {
                    currentDialogueGroup = [...dialogEntries];
                    playNextDialogueInGroup();
                } else {
                    dialogEntries.forEach(entry => {
                        if (entry.character === "系统") return;
                        
                        if (!dialogQueues[entry.character]) {
                            dialogQueues[entry.character] = [];
                        }
                        
                        const isDuplicate = dialogQueues[entry.character].some(item => 
                            item.message === entry.message && item.timestamp === entry.timestamp
                        );
                        
                        if (!isDuplicate) {
                            dialogQueues[entry.character].push(entry);
                        }
                    });
                }
            }
        } catch (error) {
            console.error("更新NPC对话气泡时出错:", error);
        }
    }
    
    // 对对话进行排序，使对话按照合理的顺序显示
    function sortDialogueEntries(dialogEntries) {
        if (!dialogEntries || dialogEntries.length <= 1) return dialogEntries;
        
        console.log("对话排序前:", dialogEntries.map(e => e.character));
        
        // 将对话按角色分组
        const dialoguesByCharacter = {};
        dialogEntries.forEach(entry => {
            if (!dialoguesByCharacter[entry.character]) {
                dialoguesByCharacter[entry.character] = [];
            }
            dialoguesByCharacter[entry.character].push(entry);
        });
        
        // 重新排列为交替对话模式
        const sortedDialogues = [];
        const characters = Object.keys(dialoguesByCharacter);
        
        // 特殊情况处理：如果只有系统消息，直接返回
        if (characters.length === 1 && characters[0] === "系统") {
            return dialogEntries;
        }
        
        // 如果是两个角色对话，实现交替对话模式
        if (characters.length === 2 && !characters.includes("系统")) {
            const char1 = characters[0];
            const char2 = characters[1];
            
            // 确保对话数量匹配
            const minDialogueCount = Math.min(
                dialoguesByCharacter[char1].length,
                dialoguesByCharacter[char2].length
            );
            
            // 为了实现更好的对话效果，通常是一个人先问，另一个人再回答
            // 确定谁是对话发起者
            let initiator = char1;
            let responder = char2;
            
            // 简单启发式：检查第一句话中是否包含另一个角色的名字
            if (dialoguesByCharacter[char1][0].message.includes(char2)) {
                initiator = char1;
                responder = char2;
            } else if (dialoguesByCharacter[char2][0].message.includes(char1)) {
                initiator = char2;
                responder = char1;
            }
            
            console.log(`对话发起者: ${initiator}, 回应者: ${responder}`);
            
            // 创建交替对话序列
            for (let i = 0; i < minDialogueCount; i++) {
                sortedDialogues.push(dialoguesByCharacter[initiator][i]);
                sortedDialogues.push(dialoguesByCharacter[responder][i]);
            }
            
            // 添加剩余的对话（如果有）
            if (dialoguesByCharacter[initiator].length > minDialogueCount) {
                for (let i = minDialogueCount; i < dialoguesByCharacter[initiator].length; i++) {
                    sortedDialogues.push(dialoguesByCharacter[initiator][i]);
                }
            }
            
            if (dialoguesByCharacter[responder].length > minDialogueCount) {
                for (let i = minDialogueCount; i < dialoguesByCharacter[responder].length; i++) {
                    sortedDialogues.push(dialoguesByCharacter[responder][i]);
                }
            }
        } else {
            // 如果不是两人对话，使用默认排序逻辑
            // 先显示系统消息
            if (dialoguesByCharacter["系统"]) {
                sortedDialogues.push(...dialoguesByCharacter["系统"]);
            }
            
            // 然后按照角色字母顺序排列其他角色的第一句话
            const nonSystemCharacters = characters.filter(char => char !== "系统");
            nonSystemCharacters.sort((a, b) => a.localeCompare(b));
            
            let maxDialogueCount = 0;
            nonSystemCharacters.forEach(char => {
                maxDialogueCount = Math.max(maxDialogueCount, dialoguesByCharacter[char].length);
            });
            
            // 轮流添加每个角色的对话
            for (let i = 0; i < maxDialogueCount; i++) {
                for (let char of nonSystemCharacters) {
                    if (dialoguesByCharacter[char][i]) {
                        sortedDialogues.push(dialoguesByCharacter[char][i]);
                    }
                }
            }
        }
        
        console.log("对话排序后:", sortedDialogues.map(e => e.character));
        return sortedDialogues;
    }
    
    // 播放对话组中的下一条对话
    function playNextDialogueInGroup() {
        isDialogueGroupPlaying = true;
        
        if (currentDialogueGroup.length > 0) {
            // 获取并移除第一条对话
            const nextDialogue = currentDialogueGroup.shift();
            console.log(`播放对话组中的下一条: ${nextDialogue.character} 说: ${nextDialogue.message.substring(0, 30)}...`);
            
            // 显示这条对话
            forceShowNPCBubbles([nextDialogue], "dialog");
            
            // 设置定时器，在当前对话显示完毕后显示下一条
            const baseTime = 3000; // 基础时间3秒
            const charTime = 80; // 每个字符增加80毫秒
            const displayTime = Math.min(
                15000, // 最长15秒
                Math.max(5000, baseTime + nextDialogue.message.length * charTime) // 最短5秒
            );
            
            console.log(`对话显示时间: ${displayTime}毫秒`);
            
            // 清除之前的定时器
            if (dialogueGroupTimer) {
                clearTimeout(dialogueGroupTimer);
            }
            
            // 设置新的定时器
            dialogueGroupTimer = setTimeout(() => {
                // 隐藏当前对话气泡
                if (pronunciatios[nextDialogue.character] && pronunciatios[nextDialogue.character].container) {
                    pronunciatios[nextDialogue.character].container.visible = false;
                }
                
                // 如果对话组还有对话，继续播放
                if (currentDialogueGroup.length > 0) {
                    playNextDialogueInGroup();
                } else {
                    // 对话组播放完毕
                    isDialogueGroupPlaying = false;
                    dialogueGroupTimer = null;
                    
                    // 检查各角色队列中是否还有对话需要显示
                    checkAndDisplayQueuedDialogues();
                }
            }, displayTime);
        } else {
            // 对话组为空
            isDialogueGroupPlaying = false;
            dialogueGroupTimer = null;
            
            // 检查各角色队列中是否还有对话需要显示
            checkAndDisplayQueuedDialogues();
        }
    }
    
    // 检查并显示队列中的对话
    function checkAndDisplayQueuedDialogues() {
        const nextGroup = [];
        
        // 从每个角色的队列中取出一条对话
        for (let personaName in dialogQueues) {
            if (dialogQueues[personaName] && dialogQueues[personaName].length > 0) {
                nextGroup.push(dialogQueues[personaName].shift());
            }
        }
        
        if (nextGroup.length > 0) {
            // 排序新的对话组
            sortDialogueEntries(nextGroup);
            
            // 设置为当前对话组并开始播放
            currentDialogueGroup = nextGroup;
            playNextDialogueInGroup();
        }
    }

    // 显示下一条对话
    function displayNextDialogue(personaName) {
        if (!dialogQueues[personaName] || dialogQueues[personaName].length === 0) {
            console.log(`${personaName} 的对话队列为空`);
            return;
        }
        
        // 取出队列中的第一条对话
        const nextDialogue = dialogQueues[personaName][0];
        console.log(`显示 ${personaName} 的下一条对话: ${nextDialogue.message}`);
        
        // 显示对话气泡
        forceShowNPCBubbles([nextDialogue], "dialog");
    }
    
    // 强制显示NPC气泡，增加类型参数
    function forceShowNPCBubbles(dialogEntries, bubbleType = "dialog") {
        
        // 检查对话气泡的全局显示状态 - 如果是对话气泡且全局禁用显示，则直接返回
        if (bubbleType === "dialog" && !globalShowDialogBubbles) {
            console.log("对话气泡已被全局禁用，跳过显示");
            return;
        }
        
        // 判断显示时间
        const displayTime = bubbleType === "dialog" ? 15000 : 10000; // 对话气泡30秒，动作气泡8秒
        
        try {
            // 遍历所有对话
            dialogEntries.forEach(entry => {
                const personaName = entry.character;
                const message = entry.message;
                const emoji = bubbleType === "dialog" ? (entry.emoji || "") : ""; // 动作气泡不显示表情
                
                // 跳过系统消息
                if (personaName === "系统") return;
                
                // 获取NPC对象
                const npc = personas[personaName];
                if (!npc) {
                    console.warn(`找不到角色 ${personaName}`);
                    return;
                }
                
                // 检查气泡是否存在
                let bubble = pronunciatios[personaName];
                if (!bubble || !bubble.container) {
                    console.warn(`${personaName} 的气泡不存在，尝试创建`);
                    createDialogueBubble(npc, personaName);
                    bubble = pronunciatios[personaName];
                }
                
                // 强制更新气泡内容和大小
                if (bubble && bubble.text && bubble.background) {
                    // 如果当前有对话气泡在显示，且要显示动作气泡，则跳过
                    if (bubbleType === "action" && 
                        bubbleTimers[personaName] && 
                        bubbleTimers[personaName].dialog) {
                        console.log(`${personaName} 当前有对话气泡显示，跳过显示动作气泡`);
                        return;
                    }
                    
                    // 准备消息文本
                    const rawDisplayText = emoji ? `${emoji} ${message}` : message;
                    // 使用格式化函数处理文本，添加换行符
                    const displayText = bubbleType === "dialog" ? formatBubbleText(rawDisplayText) : formatActionText(rawDisplayText);
                    
                    // 清除现有打字效果
                    if (typingEffects[personaName]) {
                        clearInterval(typingEffects[personaName].interval);
                        delete typingEffects[personaName];
                    }
                    
                    // 重置文本内容为空
                    bubble.text.text = "";
                    
                    // 根据气泡类型选择不同的背景颜色
                    // 对话气泡：淡橙黄色背景 (0xFFEE88) + 橙色边框 (0xFF8C00)
                    // 活动气泡：淡紫色背景 (0xE6E6FA) + 紫色边框 (0x9370DB) - 活动气泡颜色代码
                    const bgColor = bubbleType === "dialog" ? 0xFFEE88 : 0xE6E6FA;
                    const borderColor = bubbleType === "dialog" ? 0xFF8C00 : 0x9370DB;
                    
                    // 先使用完整文本计算气泡大小
                    const tempTextStyle = Object.assign({}, bubble.text.style);
                    applyBubbleTextStyle(tempTextStyle, bubbleType);
                    
                    // 对于活动气泡，确保文本样式禁用自动换行
                    if (bubbleType === "action") {
                        tempTextStyle.wordWrap = false;
                        tempTextStyle.fontSize = 12;
                    }
                    
                    const tempText = new PIXI.Text(displayText, tempTextStyle);
                    
                    // 先将气泡绘制为完整文本所需的大小
                    bubble.background.clear();
                    bubble.background.beginFill(bgColor);
                    bubble.background.lineStyle(3, borderColor, 0.8);
                    
                    // 为活动气泡提供更宽的背景
                    if (bubbleType === "action") {
                        // 活动气泡禁用了换行，需要更宽的背景
                        bubble.background.drawRoundedRect(0, 0, tempText.width + 50, tempText.height + 8, 10);
                    } else {
                        // 对话气泡使用正常宽度
                        bubble.background.drawRoundedRect(0, 0, tempText.width + 20, tempText.height + 8, 10);
                    }
                    bubble.background.endFill();
                    
                    // 保存完整文本的宽高，用于打字机效果
                    const fullTextWidth = tempText.width;
                    const fullTextHeight = tempText.height;
                    
                    // 强制设置zIndex确保可见
                    bubble.container.zIndex = 9999;
                    
                    // 确保气泡可见
                    bubble.container.visible = true;
                    bubble.text.visible = true;
                    bubble.background.visible = true;
                    
                    // 更新气泡位置居中并调整缩放
                    updateBubblePosition(personaName);
                    
                    // 记录当前气泡类型
                    if (bubbleType === "dialog") {
                        dialogBubbles[personaName] = message;
                        // 如果有动作气泡，清除它
                        delete actionBubbles[personaName];
                        if (bubbleTimers[personaName] && bubbleTimers[personaName].action) {
                            clearTimeout(bubbleTimers[personaName].action);
                            bubbleTimers[personaName].action = null;
                        }
                    } else {
                        actionBubbles[personaName] = message;
                    }
                    
                    // 设置自动隐藏定时器
                    if (!bubbleTimers[personaName]) {
                        bubbleTimers[personaName] = {};
                    }
                    
                    // 先清除之前的定时器
                    if (bubbleTimers[personaName][bubbleType]) {
                        clearTimeout(bubbleTimers[personaName][bubbleType]);
                    }
                    
                    // 创建打字效果 (仅对话气泡)
                    if (bubbleType === "dialog") {
                        // 保存完整消息和当前显示位置
                        typingEffects[personaName] = {
                            fullText: displayText,
                            currentPos: 0,
                            interval: null,
                            fullTextWidth: fullTextWidth,
                            fullTextHeight: fullTextHeight,
                            lastUpdateTime: Date.now()
                        };
                        
                        // 使用requestAnimationFrame代替setInterval实现更流畅的打字效果
                        const animate = () => {
                            const effect = typingEffects[personaName];
                            if (!effect) return;

                            const now = Date.now();
                            const elapsed = now - effect.lastUpdateTime;
                            
                            // 每50毫秒更新一个字符
                            if (elapsed >= 50) {
                                if (effect.currentPos < effect.fullText.length) {
                                    effect.currentPos++;
                                    bubble.text.text = effect.fullText.substring(0, effect.currentPos);
                                    // 确保每次更新文本时强制应用自动换行
                                    bubble.text.style.wordWrap = true;
                                    bubble.text.style.wordWrapWidth = 40;
                                    
                                    // 如果文本超出预设宽度，调整气泡大小
                                    if (bubble.text.width > effect.fullTextWidth) {
                                        effect.fullTextWidth = bubble.text.width;
                                        bubble.background.clear();
                                        bubble.background.beginFill(bgColor);
                                        bubble.background.lineStyle(3, borderColor, 0.8);
                                        bubble.background.drawRoundedRect(0, 0, effect.fullTextWidth + 20, effect.fullTextHeight + 8, 10);
                                        bubble.background.endFill();
                                        
                                        // 重新居中气泡
                                        updateBubblePosition(personaName);
                                    }
                                    
                                    effect.lastUpdateTime = now;
                                    requestAnimationFrame(animate);
                                }
                            } else {
                                requestAnimationFrame(animate);
                            }
                        };
                        
                        // 启动动画
                        requestAnimationFrame(animate);
                    } else {
                        // 动作气泡直接显示全部文字
                        bubble.text.text = displayText;
                    }
                    
                    // 设置新的定时器
                    bubbleTimers[personaName][bubbleType] = setTimeout(() => {
                        // 从队列中移除已显示的对话
                        if (bubbleType === "dialog" && dialogQueues[personaName] && dialogQueues[personaName].length > 0) {
                            // 移除第一条对话
                            dialogQueues[personaName].shift();
                            console.log(`已从 ${personaName} 的队列移除一条对话，剩余: ${dialogQueues[personaName].length}`);
                            
                            // 如果队列中还有对话，继续显示下一条
                            if (dialogQueues[personaName].length > 0) {
                                // 延迟一小段时间后显示下一条，让用户有时间看到气泡消失
                                setTimeout(() => {
                                    displayNextDialogue(personaName);
                                }, 1000);
                                return; // 不隐藏气泡，等待下一条对话
                            }
                        }
                        
                        // 如果是对话气泡超时，检查是否需要显示动作气泡
                        if (bubbleType === "dialog" && actionBubbles[personaName]) {
                            // 清除打字效果
                            if (typingEffects[personaName]) {
                                clearInterval(typingEffects[personaName].interval);
                                delete typingEffects[personaName];
                            }
                            
                            // 切换到动作气泡
                            bubble.text.text = formatActionText(actionBubbles[personaName]);
                            // 禁用动作气泡的自动换行，确保只显示一行
                            bubble.text.style.wordWrap = false;
                            bubble.text.style.fontSize = 12;
                            bubble.text.style.wordWrapWidth = 40;
                            
                            // 使用动作气泡的样式
                            bubble.background.clear();
                            bubble.background.beginFill(0xE6E6FA); // 活动气泡淡紫色背景
                            bubble.background.lineStyle(3, 0x9370DB, 0.8); // 活动气泡紫色边框
                            // 为动作气泡提供更宽的背景
                            bubble.background.drawRoundedRect(0, 0, bubble.text.width + 50, bubble.text.height + 8, 10);
                            bubble.background.endFill();
                            
                            // 设置动作气泡的定时器
                            bubbleTimers[personaName].action = setTimeout(() => {
                                bubble.container.visible = false;
                                delete actionBubbles[personaName];
                                
                                // 检查是否还有更多对话需要显示
                                if (dialogQueues[personaName] && dialogQueues[personaName].length > 0) {
                                    setTimeout(() => {
                                        displayNextDialogue(personaName);
                                    }, 500);
                                }
                            }, 8000);
                        } else {
                            // 直接隐藏气泡
                            bubble.container.visible = false;
                            
                            // 清除打字效果
                            if (typingEffects[personaName]) {
                                clearInterval(typingEffects[personaName].interval);
                                delete typingEffects[personaName];
                            }
                        }
                        
                        // 清除对应的存储和定时器
                        if (bubbleType === "dialog") {
                            delete dialogBubbles[personaName];
                            bubbleTimers[personaName].dialog = null;
                        } else {
                            delete actionBubbles[personaName];
                            bubbleTimers[personaName].action = null;
                        }
                    }, displayTime);
                    
                } else {
                    console.error(`${personaName} 的气泡对象不完整:`, bubble);
                }
            });
            
            // 强制整个舞台排序
            app.stage.sortableChildren = true;
            app.stage.sortChildren();
            
        } catch (error) {
            // console.error(`强制显示NPC ${bubbleType}气泡时出错:`, error);
        }
    }
    
    // 创建角色对话气泡
    function createDialogueBubble(personaSprite, personaName) {
        // 创建基础容器
        const dialogueContainer = new PIXI.Container();
        dialogueContainer.name = `dialogue_${personaName}`;
        dialogueContainer.zIndex = 9999;
        
        // 创建背景和文本
        const background = new PIXI.Graphics();
        background.name = "dialogue_bg";
        
        const text = new PIXI.Text("", {
            fontFamily: 'Arial',
            fontSize: 14,
            fill: 0x000000,
            align: 'left',
            wordWrap: true,
            wordWrapWidth: 40,
            lineHeight: 10
        });
        text.name = "dialogue_text";
        text.x = 8;
        text.y = 4;
        
        // 组装气泡
        dialogueContainer.addChild(background);
        dialogueContainer.addChild(text);
        
        // 设置位置和可见性
        dialogueContainer.x = personaSprite.width / 2 - 100;
        dialogueContainer.y = -70;
        dialogueContainer.visible = false;
        
        // 添加到角色精灵
        personaSprite.addChild(dialogueContainer);
        
        // 记录气泡引用
        pronunciatios[personaName] = {
            container: dialogueContainer,
            background: background,
            text: text,
            personaName: personaName
        };
    }
    
    // 创建或更新动作气泡
    function updateActionBubble(personaName, action, emoji = "") {
        if (!action?.trim()) return;
        
        const formattedAction = formatActionText(action);
        const actionEntries = [{
            character: personaName,
            message: formattedAction,
            emoji: ""
        }];
        
        // 取消现有的动作气泡计时器
        if (bubbleTimers[personaName]?.action) {
            clearTimeout(bubbleTimers[personaName].action);
            bubbleTimers[personaName].action = null;
        }
        
        // 显示新的动作气泡
        forceShowNPCBubbles(actionEntries, "action");
    }
    
    // 格式化活动文本
    function formatActionText(text) {
        if (!text?.trim()) return "";
        
        // 移除换行和多余空格
        text = text.replace(/\n/g, " ").replace(/\s+/g, " ").trim();
        
        // 处理特殊活动文本
        if (text.includes("睡觉")) return "睡觉中";
        if (text.includes("前往")) {
            const match = text.match(/前往\s*(.+)/);
            return match?.[1] ? `前往${match[1].trim()}` : text;
        }
        
        // 截断长文本
        return text.length > 30 ? text.slice(0, 30) + "..." : text;
    }

    // 初始化游戏
    function initGame() {
        // 使用waitForPixi等待PIXI加载完成
        waitForPixi(function() {
            try {
                console.log("PIXI已加载，开始初始化游戏...");
                // 创建PIXI应用（受性能模式控制）
                const gameContainer = document.getElementById('game-container');
                const perf = getPerformanceConfig(performanceMode);
                app = new PIXI.Application({
                    width: gameContainer.clientWidth,
                    height: gameContainer.clientHeight,
                    backgroundColor: 0x00FF00,
                    resolution: perf.resolution,
                    autoDensity: perf.autoDensity,
                    antialias: perf.antialias,
                    powerPreference: perf.powerPreference,
                    preserveDrawingBuffer: perf.preserveDrawingBuffer
                });
                
                // 设置渲染质量（按性能模式）
                PIXI.settings.SCALE_MODE = perf.scaleMode;
                PIXI.settings.ROUND_PIXELS = perf.roundPixels;
                
                // 不限制目标帧率
                
                // 添加到DOM
                // const gameContainer = document.getElementById('game-container'); // 已在上方声明
                gameContainer.appendChild(app.view);
                if (perf.willReadFrequently) {
                    app.view.getContext('2d', { willReadFrequently: true });
                }
                
                // 确保Canvas对象使用willReadFrequently属性（按性能模式）
                if (perf.willReadFrequently) {
                    setCanvasWillReadFrequently();
                }
                
                // 创建游戏容器
                container = new PIXI.Container();
                app.stage.addChild(container);
                
                // 居中视图
                app.stage.position.set(app.screen.width / 2, app.screen.height / 2);
                
                // 设置缩放
                container.scale.set(zoom);
                
                // 加载纹理
                loadTextures();
                
                // 设置事件监听
                setupEventListeners();
                
                // 设置缩放控制
                setupZoomControls();
                
                // 加载完成后的处理
                app.loader.load((loader, resources) => {
                    // 初始化地图
                    initMap();
                    
                    // 初始化NPC
                    initNPC();
                    
                    // 开始游戏循环
                    app.ticker.add(gameLoop);
                    
                    // 设置初始时间
                    updateGameTime();
                    
                    // 每5秒更新一次对话气泡
                    setInterval(updateNPCBubbles, 5000);
                    
                    // 两秒后测试气泡
                    setTimeout(() => {
                        testAllNPCBubbles();
                    }, 2000);
                });
                
                // 窗口大小调整
                window.addEventListener('resize', handleResize);
                
                // 初始设置画面比例
                setTimeout(() => {
                    handleResize();
                }, 500);
                
            } catch (error) {
                console.error("初始化游戏时出错:", error);
                alert("游戏初始化失败，请刷新页面重试。错误: " + error.message);
            }
        });
    }

    // 获取角色状态
    function getPersonaStatus(personaName) {
        // 检查当前步骤是否有该角色的数据
        const currentStepKey = step.toString();
        if (all_movement[currentStepKey] && all_movement[currentStepKey][personaName]) {
            return all_movement[currentStepKey][personaName];
        }
        
        // 如果没有，检查前一步是否有该角色的数据
        const prevStepKey = (step - 1).toString();
        if (all_movement[prevStepKey] && all_movement[prevStepKey][personaName]) {
            return all_movement[prevStepKey][personaName];
        }
        
        // 如果都没有，返回null
        return null;
    }

    // 创建浮动时钟窗口按钮，添加到右侧时间容器中
    function createFloatingClockButton() {
        // 等UI创建完成后再添加按钮
        const timeDisplayCheck = setInterval(() => {
            const timeDisplayElement = document.getElementById('time-display');
            if (timeDisplayElement && currentTimeText) {
                clearInterval(timeDisplayCheck);
                
                // 创建浮动时钟按钮
                const floatingClockBtn = document.createElement('button');
                floatingClockBtn.innerHTML = '⬆️';
                floatingClockBtn.title = '显示浮动时钟';
                floatingClockBtn.style.marginLeft = '5px';
                floatingClockBtn.style.backgroundColor = 'transparent';
                floatingClockBtn.style.border = 'none';
                floatingClockBtn.style.color = 'white';
                floatingClockBtn.style.fontSize = '14px';
                floatingClockBtn.style.cursor = 'pointer';
                floatingClockBtn.style.padding = '3px';
                floatingClockBtn.style.borderRadius = '3px';
                
                floatingClockBtn.addEventListener('mouseover', () => {
                    floatingClockBtn.style.backgroundColor = 'rgba(255,255,255,0.2)';
                });
                
                floatingClockBtn.addEventListener('mouseout', () => {
                    floatingClockBtn.style.backgroundColor = 'transparent';
                });
                
                floatingClockBtn.addEventListener('click', () => {
                    console.log("点击了浮动时钟按钮");
                    toggleFloatingClock();
                });
                
                currentTimeText.appendChild(floatingClockBtn);
            }
        }, 500);
    }
    
    // 更新游戏时间函数
    function updateGameTime() {
        try {
            console.log("初始化游戏时间...");
            // 更新时间显示
            updateTimeDisplay();
            // 创建浮动时钟按钮（如果需要）
            if (typeof createFloatingClockButton === 'function') {
                createFloatingClockButton();
            } else {
                console.warn("createFloatingClockButton 函数未定义，无法创建浮动时钟按钮");
            }
            console.log("游戏时间初始化完成");
        } catch (error) {
            console.error("更新游戏时间时出错:", error);
        }
    }
    
    // 浮动时钟计时器ID管理
    let floatingClockUpdateInterval = null;
    
    // 创建/显示/隐藏浮动时钟窗口
    function toggleFloatingClock() {
        if (floatingClockWindow) {
            // 如果已存在，则移除并清理计时器
            if (floatingClockUpdateInterval) {
                clearInterval(floatingClockUpdateInterval);
                floatingClockUpdateInterval = null;
            }
            document.body.removeChild(floatingClockWindow);
            floatingClockWindow = null;
            return;
        }
        
        // 创建浮动窗口
        floatingClockWindow = document.createElement('div');
        floatingClockWindow.className = 'floating-window';
        floatingClockWindow.style.left = '20px';
        floatingClockWindow.style.top = '20px';
        
        // 窗口头部
        const windowHeader = document.createElement('div');
        windowHeader.className = 'window-header';
        
        const windowTitle = document.createElement('div');
        windowTitle.className = 'window-title';
        windowTitle.textContent = '游戏时间';
        
        const closeButton = document.createElement('button');
        closeButton.className = 'window-close';
        closeButton.innerHTML = '×';
        closeButton.addEventListener('click', () => {
            toggleFloatingClock();
        });
        
        windowHeader.appendChild(windowTitle);
        windowHeader.appendChild(closeButton);
        
        // 窗口内容
        const windowContent = document.createElement('div');
        windowContent.className = 'window-content';
        
        const clockDate = document.createElement('div');
        clockDate.className = 'clock-date';
        
        const clockDisplay = document.createElement('div');
        clockDisplay.className = 'clock-display';
        
        windowContent.appendChild(clockDate);
        windowContent.appendChild(clockDisplay);
        
        floatingClockWindow.appendChild(windowHeader);
        floatingClockWindow.appendChild(windowContent);
        
        document.body.appendChild(floatingClockWindow);
        
        // 更新时钟显示
        updateFloatingClock();
        
        // 设置定时更新 - 使用setInterval代替递归setTimeout
        if (floatingClockUpdateInterval) {
            clearInterval(floatingClockUpdateInterval);
        }
        floatingClockUpdateInterval = setInterval(updateFloatingClock, 1000);
        
        // 实现拖动功能
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        
        windowHeader.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragOffsetX = e.clientX - floatingClockWindow.offsetLeft;
            dragOffsetY = e.clientY - floatingClockWindow.offsetTop;
            floatingClockWindow.style.cursor = 'grabbing';
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const newLeft = e.clientX - dragOffsetX;
            const newTop = e.clientY - dragOffsetY;
            
            // 确保窗口不会被拖出视口
            const maxLeft = window.innerWidth - floatingClockWindow.offsetWidth;
            const maxTop = window.innerHeight - floatingClockWindow.offsetHeight;
            
            floatingClockWindow.style.left = `${Math.max(0, Math.min(newLeft, maxLeft))}px`;
            floatingClockWindow.style.top = `${Math.max(0, Math.min(newTop, maxTop))}px`;
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                floatingClockWindow.style.cursor = 'default';
            }
        });
    }
    
    // 更新浮动时钟显示
    function updateFloatingClock() {
        if (!floatingClockWindow) {
            // 如果时钟窗口不存在，清理计时器
            if (floatingClockUpdateInterval) {
                clearInterval(floatingClockUpdateInterval);
                floatingClockUpdateInterval = null;
            }
            return;
        }
        
            const clockDate = floatingClockWindow.querySelector('.clock-date');
            const clockDisplay = floatingClockWindow.querySelector('.clock-display');
            
            if (clockDate && clockDisplay) {
                const currentDate = new Date(start_datetime.getTime());
                
                // 显示格式化的日期
                const year = currentDate.getFullYear();
                const month = (currentDate.getMonth() + 1).toString().padStart(2, '0');
                const day = currentDate.getDate().toString().padStart(2, '0');
                const weekday = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'][currentDate.getDay()];
                
                // 显示格式化的时间
                const hours = currentDate.getHours().toString().padStart(2, '0');
                const minutes = currentDate.getMinutes().toString().padStart(2, '0');
                const seconds = currentDate.getSeconds().toString().padStart(2, '0');
                
                clockDate.textContent = `${year}年${month}月${day}日 ${weekday}`;
                clockDisplay.textContent = `${hours}:${minutes}:${seconds}`;
        }
    }

    // 添加内存管理和性能优化变量
    let memoryCleanupInterval = 300000; // 每5分钟清理一次内存
    let lastMemoryCleanup = Date.now();
    let maxDialogHistorySize = 50; // 最大保存的对话记录数量
    let bubbleTimersToRemove = [];  // 需要删除的气泡计时器
    let frameSkipCounter = 0; // 帧数跳过计数器
    let frameSkipThreshold = 2; // 每隔几帧执行一次完整更新（值越大性能越好但动画可能不流畅）
    
    // 更新对话历史记录功能，添加大小限制
    function addDialogToHistory(sender, message, time) {
        // 首先检查历史记录大小
        let historyKeys = Object.keys(dialogHistory);
        if (historyKeys.length > maxDialogHistorySize) {
            // 删除最旧的几条记录，保留80%
            const keysToRemove = historyKeys.slice(0, Math.floor(historyKeys.length * 0.2));
            keysToRemove.forEach(key => delete dialogHistory[key]);
            console.log(`清理过多的对话历史记录，移除了${keysToRemove.length}条旧记录`);
        }
        
        // 添加新记录
        const dialogId = `dialog_${Date.now()}_${Math.floor(Math.random() * 10000)}`;
        dialogHistory[dialogId] = { sender, message, time };
    }

    // 优化定时器清理，确保不会累积未使用的定时器
    function showDialogBubble(personaName, text, duration = 5000) {
        try {
            // 检查角色名称和发言是否有效
            if (!personaName || !text || text.trim() === '') {
                console.warn(`无效的气泡参数 (${personaName}): ${text}`);
                return;
            }
            
            // 获取角色和气泡
            const npc = personas[personaName];
            const bubble = pronunciatios[personaName];
            
            if (!npc) {
                console.warn(`找不到角色: ${personaName}`);
                return;
            }
            
            if (!bubble || !bubble.container || !bubble.text || !bubble.background) {
                console.warn(`找不到气泡: ${personaName}`);
                return;
            }
            
            // 准备气泡内容
            const displayText = text;
            
            // 清除角色现有的定时器
            if (bubbleTimers[personaName]) {
                clearTimeout(bubbleTimers[personaName]);
                delete bubbleTimers[personaName];
            }
            
            // 清除现有打字效果
            if (typingEffects[personaName]) {
                clearInterval(typingEffects[personaName].interval);
                delete typingEffects[personaName];
            }
            
            // 重置文本内容
            bubble.text.text = displayText;
            
            // 设置气泡背景样式
            const padding = 10;
            bubble.background.clear();
            bubble.background.beginFill(0xFFEE88);
            bubble.background.lineStyle(2, 0xFF8C00, 0.8);
            bubble.background.drawRoundedRect(
                0, 0, 
                bubble.text.width + padding * 2, 
                bubble.text.height + padding * 2,
                10
            );
            bubble.background.endFill();
            
            // 调整文本位置
            bubble.text.x = padding;
            bubble.text.y = padding;
            
            // 确保气泡在最上层并可见
            bubble.container.zIndex = 9999;
            bubble.container.visible = true;
            bubble.container.alpha = 1;
            
            // 更新气泡位置和缩放
            updateBubblePosition(personaName);
            
            // 创建唯一的定时器ID
            const timerId = `${personaName}_${Date.now()}`;
            
            // 设置自动隐藏定时器
            const timer = setTimeout(() => {
                // 隐藏气泡
                if (bubble && bubble.container) {
                    bubble.container.visible = false;
                }
                
                // 定时器执行后从管理对象中删除
                delete bubbleTimers[timerId];
                
                console.log(`气泡自动隐藏 (${personaName}): ${timerId.slice(-6)}`);
            }, duration);
            
            // 存储定时器信息（带有额外信息方便调试）
            bubbleTimers[timerId] = {
                timer: timer,
                personaName: personaName,
                text: text.slice(0, 20) + (text.length > 20 ? '...' : ''),
                createdAt: Date.now(),
                expirationTime: Date.now() + duration + 1000, // 添加1秒缓冲
                duration: duration
            };
            
            console.log(`显示气泡 (${personaName}): ${timerId.slice(-6)}, 持续时间: ${duration}ms`);
            return timerId;
        } catch (error) {
            console.error(`显示对话气泡时出错 (${personaName}):`, error);
            return null;
        }
    }
    
    // 隐藏对话气泡
    function hideDialogBubble(personaName) {
        try {
            const bubble = pronunciatios[personaName];
            if (bubble && bubble.container) {
                bubble.container.visible = false;
            }
            
            // 清理该角色的所有计时器
            for (let timerId in bubbleTimers) {
                if (bubbleTimers[timerId].personaName === personaName) {
                    clearTimeout(bubbleTimers[timerId].timer);
                    delete bubbleTimers[timerId];
                }
            }
        } catch (error) {
            console.error(`隐藏对话气泡时出错 (${personaName}):`, error);
        }
    }

    // 添加PIXI渲染优化设置
    PIXI.settings.PRECISION_FRAGMENT = PIXI.PRECISION.MEDIUM; // 降低片段着色器精度
    PIXI.settings.GC_MODE = PIXI.GC_MODES.AUTO; // 启用自动垃圾回收
    PIXI.settings.GC_MAX_IDLE = 60 * 10; // 10分钟的最大空闲时间
    PIXI.settings.WRAP_MODE = PIXI.WRAP_MODES.CLAMP; // 边缘包装模式
    PIXI.settings.MIPMAP_TEXTURES = PIXI.MIPMAP_MODES.ON; // 启用mipmap以提高缩放性能

    // 增强自动滚动到最新消息的功能
    let autoScrollEnabled = true; // 默认启用自动滚动
    
    // 自动滚动函数
    function scrollToLatestMessage() {
        const scrollContainer = document.getElementById('ui-dialog-panel'); 
        if (!scrollContainer) {
            console.error("scrollToLatestMessage: scrollContainer (ui-dialog-panel) not found");
            return;
        }

        console.log(`[Before Scroll] autoScrollEnabled: ${autoScrollEnabled}`);
        if (!autoScrollEnabled) {
            return;
        }

        console.log(`[Before Scroll] scrollTop: ${scrollContainer.scrollTop}, scrollHeight: ${scrollContainer.scrollHeight}, clientHeight: ${scrollContainer.clientHeight}`);

        const previousScrollBehavior = scrollContainer.style.scrollBehavior; 
        scrollContainer.style.scrollBehavior = 'auto'; 
        scrollContainer.scrollTop = scrollContainer.scrollHeight;
        
        console.log(`[After Scroll] scrollTop: ${scrollContainer.scrollTop}, scrollHeight: ${scrollContainer.scrollHeight}, clientHeight: ${scrollContainer.clientHeight}`);

        setTimeout(() => {
            scrollContainer.style.scrollBehavior = previousScrollBehavior;
        }, 0);
    }
    
    // 添加自动滚动开关
    function addAutoScrollToggle(container) {
        // 创建开关容器
        const toggleContainer = document.createElement('div');
        toggleContainer.style.position = 'absolute';
        toggleContainer.style.top = '5px';
        toggleContainer.style.right = '10px';
        toggleContainer.style.zIndex = '1000';
        toggleContainer.style.display = 'flex';
        toggleContainer.style.alignItems = 'center';
        toggleContainer.style.gap = '5px';
        
        // 创建标签
        const label = document.createElement('span');
        label.textContent = '自动滚动:';
        label.style.fontSize = '12px';
        label.style.color = '#666';
        
        // 创建开关按钮
        const toggle = document.createElement('button');
        toggle.textContent = autoScrollEnabled ? '✓' : '✗';
        toggle.style.width = '24px';
        toggle.style.height = '24px';
        toggle.style.borderRadius = '50%';
        toggle.style.border = 'none';
        toggle.style.background = autoScrollEnabled ? '#4CAF50' : '#F44336';
        toggle.style.color = 'white';
        toggle.style.cursor = 'pointer';
        toggle.style.fontSize = '12px';
        toggle.style.display = 'flex';
        toggle.style.justifyContent = 'center';
        toggle.style.alignItems = 'center';
        
        // 添加点击事件
        toggle.addEventListener('click', function() {
            autoScrollEnabled = !autoScrollEnabled;
            toggle.textContent = autoScrollEnabled ? '✓' : '✗';
            toggle.style.background = autoScrollEnabled ? '#4CAF50' : '#F44336';
            
            // 如果启用了自动滚动，立即滚动到底部
            if (autoScrollEnabled) {
                scrollToLatestMessage();
            }
            
            console.log(`自动滚动已${autoScrollEnabled ? '启用' : '禁用'}`);
        });
        
        // 添加到容器
        toggleContainer.appendChild(label);
        toggleContainer.appendChild(toggle);
        container.appendChild(toggleContainer);
    }

    // 这里的变量声明是重复的，会导致错误，所以删除
    // var characterImages = {}; // 角色头顶图片资源映射
    // var characterHeadImages = {}; // 存储角色头顶显示的图片

    // 强制更新UI位置和可见性 - 优化版本
    function forceUpdateUI() {
        updateTimeDisplay();
        updateUIPositions();
    }

    // 全局变量，用于保存设置面板
    let settingsWindow = null;
    
    // 全局变量，用于保存网页模拟面板
    let webSimPanel = null;
    
    // 用于跟踪已显示的网页模拟文件
    let displayedWebSims = new Set(); // 存储已显示的文件名
    let webSimMonitorInterval = null; // 监控定时器
    
    // 全局变量，用于保存音乐面板
    let musicPanel = null;
    
    // 用于跟踪已显示的音乐文件
    let displayedMusic = new Set(); // 存储已显示的文件名
    let musicMonitorInterval = null; // 监控定时器

    // 新的全局函数来控制碰撞框的显示状态并更新设置面板按钮样式
    function setGlobalCollisionBoxVisibility(shouldShow) {
        globalShowCollisionBoxes = shouldShow;
        showAllCollisionBoxes(globalShowCollisionBoxes); // 应用更改

        // 更新设置面板中按钮的样式
        if (settingsWindow) {
            const showBtn = settingsWindow.querySelector('#settings-show-collision-btn');
            const hideBtn = settingsWindow.querySelector('#settings-hide-collision-btn');
            if (showBtn && hideBtn) {
                if (shouldShow) {
                    showBtn.style.opacity = '0.7'; // "显示"按钮变为半透明 (表示已激活)
                    hideBtn.style.opacity = '1';   // "隐藏"按钮完全不透明
                } else {
                    showBtn.style.opacity = '1';   // "显示"按钮完全不透明
                    hideBtn.style.opacity = '0.7'; // "隐藏"按钮变为半透明 (表示已激活)
                }
            }
        }
    }

    // 显示/隐藏设置窗口
    function toggleSettingsWindow() {
        if (settingsWindow) {
            // 如果已存在，则移除
            document.body.removeChild(settingsWindow);
            settingsWindow = null;
            return;
        }
        
        // 创建设置窗口
        settingsWindow = document.createElement('div');
        settingsWindow.className = 'floating-window settings-panel'; // Add new class for specific styling
        settingsWindow.style.width = '350px'; // Slightly wider for better layout
        settingsWindow.style.left = '50%';
        settingsWindow.style.top = '80px'; // 调整初始位置
        settingsWindow.style.transform = 'translateX(-50%)';
        settingsWindow.style.maxHeight = 'calc(100vh - 160px)'; // 确保在视口内
        settingsWindow.style.overflowY = 'auto';
        
        // 窗口头部
        const windowHeader = document.createElement('div');
        windowHeader.className = 'window-header';
        
        const windowTitle = document.createElement('div');
        windowTitle.className = 'window-title';
        windowTitle.textContent = '⚙️ 设置面板';
        
        const closeButton = document.createElement('button');
        closeButton.className = 'window-close';
        closeButton.innerHTML = '×';
        closeButton.addEventListener('click', () => {
            toggleSettingsWindow();
        });
        
        windowHeader.appendChild(windowTitle);
        windowHeader.appendChild(closeButton);
        
        // 窗口内容容器
        const windowContent = document.createElement('div');
        windowContent.className = 'window-content';
        
        // 创建气泡控制部分
        const bubbleSection = document.createElement('div');
        bubbleSection.style.marginBottom = '20px';
        
        // 气泡控制标题
        const bubbleControlTitle = document.createElement('div');
        bubbleControlTitle.textContent = '💬 气泡控制';
        bubbleControlTitle.style.color = 'var(--accent-primary, #d4af37)';
        bubbleControlTitle.style.fontSize = '16px';
        bubbleControlTitle.style.fontWeight = '700';
        bubbleControlTitle.style.marginBottom = '15px';
        bubbleControlTitle.style.paddingBottom = '10px';
        bubbleControlTitle.style.borderBottom = '2px solid var(--border-color, #4a3f2a)';
        bubbleControlTitle.style.textShadow = '0 0 5px rgba(212, 175, 55, 0.5)';
        bubbleControlTitle.style.letterSpacing = '0.5px';
        bubbleSection.appendChild(bubbleControlTitle);
        
        // 创建气泡大小控制
        const bubbleScaleContainer = document.createElement('div');
        bubbleScaleContainer.style.display = 'flex';
        bubbleScaleContainer.style.alignItems = 'center';
        bubbleScaleContainer.style.gap = '5px';
        bubbleScaleContainer.style.marginBottom = '10px';
        
        const bubbleScaleLabel = document.createElement('span');
        bubbleScaleLabel.textContent = '大小:';
        bubbleScaleLabel.className = 'control-label'; // Use new class
        bubbleScaleLabel.style.width = 'auto'; // Let content define width
        bubbleScaleContainer.appendChild(bubbleScaleLabel);
        
        const bubbleScaleSlider = document.createElement('input');
        bubbleScaleSlider.type = 'range';
        bubbleScaleSlider.min = '0.5';
        bubbleScaleSlider.max = '2.0';
        bubbleScaleSlider.step = '0.1';
        bubbleScaleSlider.value = bubbleScale.toString();
        bubbleScaleSlider.style.width = '180px'; // Wider slider
        // Track and thumb styles now from global CSS
        bubbleScaleContainer.appendChild(bubbleScaleSlider);
        
        const bubbleScaleValue = document.createElement('span');
        bubbleScaleValue.textContent = bubbleScale.toFixed(1);
        bubbleScaleValue.className = 'control-value'; // Use new class
        bubbleScaleContainer.appendChild(bubbleScaleValue);
        
        bubbleSection.appendChild(bubbleScaleContainer);
        
        // 创建气泡垂直位置控制
        const bubbleVerticalContainer = document.createElement('div');
        bubbleVerticalContainer.style.display = 'flex';
        bubbleVerticalContainer.style.alignItems = 'center';
        bubbleVerticalContainer.style.gap = '5px';
        bubbleVerticalContainer.style.marginBottom = '10px';
        
        const bubbleVerticalLabel = document.createElement('span');
        bubbleVerticalLabel.textContent = '高度:';
        bubbleVerticalLabel.className = 'control-label';
        bubbleVerticalLabel.style.width = 'auto';
        bubbleVerticalContainer.appendChild(bubbleVerticalLabel);
        
        const bubbleVerticalSlider = document.createElement('input');
        bubbleVerticalSlider.type = 'range';
        bubbleVerticalSlider.min = '30';
        bubbleVerticalSlider.max = '200';
        bubbleVerticalSlider.step = '5';
        bubbleVerticalSlider.value = bubbleVerticalOffset.toString();
        bubbleVerticalSlider.style.width = '180px';
        bubbleVerticalSlider.style.height = '6px';
        Object.assign(bubbleVerticalSlider.style, {
            appearance: 'none',
            webkitAppearance: 'none',
            backgroundColor: '#555',
            borderRadius: '3px',
            outline: 'none',
            cursor: 'pointer'
        });
        bubbleVerticalContainer.appendChild(bubbleVerticalSlider);
        
        const bubbleVerticalValue = document.createElement('span');
        bubbleVerticalValue.textContent = bubbleVerticalOffset.toString();
        bubbleVerticalValue.className = 'control-value';
        bubbleVerticalContainer.appendChild(bubbleVerticalValue);
        
        bubbleSection.appendChild(bubbleVerticalContainer);
        
        // 创建气泡水平位置控制
        const bubbleHorizontalContainer = document.createElement('div');
        bubbleHorizontalContainer.style.display = 'flex';
        bubbleHorizontalContainer.style.alignItems = 'center';
        bubbleHorizontalContainer.style.gap = '5px';
        bubbleHorizontalContainer.style.marginBottom = '10px';
        
        const bubbleHorizontalLabel = document.createElement('span');
        bubbleHorizontalLabel.textContent = '水平:';
        bubbleHorizontalLabel.className = 'control-label';
        bubbleHorizontalLabel.style.width = 'auto';
        bubbleHorizontalContainer.appendChild(bubbleHorizontalLabel);
        
        const bubbleHorizontalSlider = document.createElement('input');
        bubbleHorizontalSlider.type = 'range';
        bubbleHorizontalSlider.min = '-200';
        bubbleHorizontalSlider.max = '200';
        bubbleHorizontalSlider.step = '5';
        bubbleHorizontalSlider.value = bubbleHorizontalOffset.toString();
        bubbleHorizontalSlider.style.width = '180px';
        bubbleHorizontalSlider.style.height = '6px';
        Object.assign(bubbleHorizontalSlider.style, {
            appearance: 'none',
            webkitAppearance: 'none',
            backgroundColor: '#555',
            borderRadius: '3px',
            outline: 'none',
            cursor: 'pointer'
        });
        bubbleHorizontalContainer.appendChild(bubbleHorizontalSlider);
        
        const bubbleHorizontalValue = document.createElement('span');
        bubbleHorizontalValue.textContent = bubbleHorizontalOffset.toString();
        bubbleHorizontalValue.className = 'control-value';
        bubbleHorizontalContainer.appendChild(bubbleHorizontalValue);
        
        bubbleSection.appendChild(bubbleHorizontalContainer);
        
        // 添加气泡控制事件监听
        bubbleScaleSlider.addEventListener('input', (e) => {
            bubbleScale = parseFloat(e.target.value);
            bubbleScaleValue.textContent = bubbleScale.toFixed(1);
            updateAllBubblePositions();
        });
        
        bubbleVerticalSlider.addEventListener('input', (e) => {
            bubbleVerticalOffset = parseInt(e.target.value);
            bubbleVerticalValue.textContent = bubbleVerticalOffset.toString();
            updateAllBubblePositions();
        });
        
        bubbleHorizontalSlider.addEventListener('input', (e) => {
            bubbleHorizontalOffset = parseInt(e.target.value);
            bubbleHorizontalValue.textContent = bubbleHorizontalOffset.toString();
            updateAllBubblePositions();
        });
        
        // 创建碰撞框控制部分
        const collisionSection = document.createElement('div');
        
        // 碰撞框控制标题
        const collisionControlTitle = document.createElement('div');
        collisionControlTitle.textContent = '⬛ 碰撞框控制';
        collisionControlTitle.style.color = 'var(--accent-primary, #d4af37)';
        collisionControlTitle.style.fontSize = '16px';
        collisionControlTitle.style.fontWeight = '700';
        collisionControlTitle.style.marginBottom = '15px';
        collisionControlTitle.style.paddingBottom = '10px';
        collisionControlTitle.style.borderBottom = '2px solid var(--border-color, #4a3f2a)';
        collisionControlTitle.style.textShadow = '0 0 5px rgba(212, 175, 55, 0.5)';
        collisionSection.appendChild(collisionControlTitle);
        
        // 创建碰撞框控制按钮
        const collisionButtonContainer = document.createElement('div');
        collisionButtonContainer.style.display = 'flex';
        collisionButtonContainer.style.gap = '10px';
        collisionButtonContainer.style.marginBottom = '10px';
        
        const showCollisionBtn = document.createElement('button');
        showCollisionBtn.textContent = '显示'; // Shorter text
        showCollisionBtn.id = 'settings-show-collision-btn';
        showCollisionBtn.className = 'ui-button ui-button-secondary'; // Use new classes
        showCollisionBtn.style.flex = '1';
        showCollisionBtn.addEventListener('click', () => {
            setGlobalCollisionBoxVisibility(true);
        });
        
        const hideCollisionBtn = document.createElement('button');
        hideCollisionBtn.textContent = '隐藏'; // Shorter text
        hideCollisionBtn.id = 'settings-hide-collision-btn';
        hideCollisionBtn.className = 'ui-button ui-button-secondary active'; // Start with hide active
        hideCollisionBtn.style.flex = '1';
        // hideCollisionBtn.style.opacity = '0.7'; // Initial state - managed by setGlobalCollisionBoxVisibility now
        hideCollisionBtn.addEventListener('click', () => {
            setGlobalCollisionBoxVisibility(false);
        });
        
        // Initial button state based on globalShowCollisionBoxes
        if (globalShowCollisionBoxes) {
            showCollisionBtn.classList.add('active');
            hideCollisionBtn.classList.remove('active');
        } else {
            showCollisionBtn.classList.remove('active');
            hideCollisionBtn.classList.add('active');
        }
        
        collisionButtonContainer.appendChild(showCollisionBtn);
        collisionButtonContainer.appendChild(hideCollisionBtn);
        
        collisionSection.appendChild(collisionButtonContainer);
        
        // 添加对话气泡显示控制
        const dialogBubbleControlContainer = document.createElement('div');
        dialogBubbleControlContainer.style.marginTop = '15px';
        dialogBubbleControlContainer.style.paddingTop = '15px';
        dialogBubbleControlContainer.style.borderTop = '1px solid var(--border-color, #4a3f2a)';
        
        const dialogBubbleControlLabel = document.createElement('div');
        dialogBubbleControlLabel.textContent = '对话气泡显示:';
        dialogBubbleControlLabel.className = 'control-label';
        dialogBubbleControlLabel.style.fontSize = '14px';
        dialogBubbleControlLabel.style.marginBottom = '10px';
        dialogBubbleControlLabel.style.color = 'var(--text-secondary, #d4c4a1)';
        dialogBubbleControlContainer.appendChild(dialogBubbleControlLabel);
        
        // 对话气泡开关按钮
        const dialogBubbleButtonContainer = document.createElement('div');
        dialogBubbleButtonContainer.style.display = 'flex';
        dialogBubbleButtonContainer.style.gap = '10px';
        dialogBubbleButtonContainer.style.marginBottom = '10px';
        
        const enableDialogBubblesBtn = document.createElement('button');
        enableDialogBubblesBtn.textContent = '启用';
        enableDialogBubblesBtn.id = 'settings-enable-dialog-bubbles-btn';
        enableDialogBubblesBtn.className = 'ui-button ui-button-secondary';
        enableDialogBubblesBtn.style.flex = '1';
        enableDialogBubblesBtn.addEventListener('click', () => {
            if (!globalShowDialogBubbles) {
                toggleDialogBubbles();
            }
        });
        
        const disableDialogBubblesBtn = document.createElement('button');
        disableDialogBubblesBtn.textContent = '禁用';
        disableDialogBubblesBtn.id = 'settings-disable-dialog-bubbles-btn';
        disableDialogBubblesBtn.className = 'ui-button ui-button-secondary active';
        disableDialogBubblesBtn.style.flex = '1';
        disableDialogBubblesBtn.addEventListener('click', () => {
            if (globalShowDialogBubbles) {
                toggleDialogBubbles();
            }
        });
        
        // 设置初始按钮状态
        if (globalShowDialogBubbles) {
            enableDialogBubblesBtn.classList.add('active');
            disableDialogBubblesBtn.classList.remove('active');
        } else {
            enableDialogBubblesBtn.classList.remove('active');
            disableDialogBubblesBtn.classList.add('active');
        }
        
        dialogBubbleButtonContainer.appendChild(enableDialogBubblesBtn);
        dialogBubbleButtonContainer.appendChild(disableDialogBubblesBtn);
        dialogBubbleControlContainer.appendChild(dialogBubbleButtonContainer);
        
        // 快捷键设置
        const shortcutKeyContainer = document.createElement('div');
        shortcutKeyContainer.style.display = 'flex';
        shortcutKeyContainer.style.alignItems = 'center';
        shortcutKeyContainer.style.gap = '10px';
        shortcutKeyContainer.style.marginBottom = '10px';
        
        const shortcutKeyLabel = document.createElement('span');
        shortcutKeyLabel.textContent = '快捷键:';
        shortcutKeyLabel.className = 'control-label';
        shortcutKeyLabel.style.width = 'auto';
        shortcutKeyContainer.appendChild(shortcutKeyLabel);
        
        const shortcutKeyInput = document.createElement('input');
        shortcutKeyInput.type = 'text';
        shortcutKeyInput.value = dialogBubbleToggleKey.toUpperCase();
        shortcutKeyInput.className = 'ui-input';
        shortcutKeyInput.style.width = '40px';
        shortcutKeyInput.style.textAlign = 'center';
        shortcutKeyInput.style.textTransform = 'uppercase';
        shortcutKeyInput.maxLength = 1;
        shortcutKeyInput.placeholder = 'D';
        shortcutKeyContainer.appendChild(shortcutKeyInput);
        
        const applyShortcutBtn = document.createElement('button');
        applyShortcutBtn.textContent = '应用';
        applyShortcutBtn.className = 'ui-button ui-button-secondary';
        applyShortcutBtn.style.minWidth = '60px';
        applyShortcutBtn.addEventListener('click', () => {
            const newKey = shortcutKeyInput.value.toLowerCase().trim();
            if (newKey && newKey.length === 1 && /^[a-z]$/.test(newKey)) {
                dialogBubbleToggleKey = newKey;
                shortcutKeyInput.value = newKey.toUpperCase();
                showSystemMessage(`对话气泡快捷键已设置为: ${newKey.toUpperCase()}`, 2000);
                console.log(`对话气泡快捷键已更新为: ${newKey}`);
            } else {
                showSystemMessage("请输入有效的字母键!", 2000);
                shortcutKeyInput.value = dialogBubbleToggleKey.toUpperCase();
            }
        });
        shortcutKeyContainer.appendChild(applyShortcutBtn);
        
        dialogBubbleControlContainer.appendChild(shortcutKeyContainer);
        
        // 添加说明文字
        const helpText = document.createElement('div');
        helpText.textContent = `当前快捷键: ${dialogBubbleToggleKey.toUpperCase()} (按键切换对话气泡显示)`;
        helpText.style.fontSize = '12px';
        helpText.style.color = 'var(--text-tertiary, #b4a481)';
        helpText.style.fontStyle = 'italic';
        helpText.style.marginTop = '5px';
        dialogBubbleControlContainer.appendChild(helpText);
        
        bubbleSection.appendChild(dialogBubbleControlContainer);
        
        // 创建画面比例控制部分
        const aspectSection = document.createElement('div');
        
        // 画面比例控制标题
        const aspectControlTitle = document.createElement('div');
        aspectControlTitle.textContent = '📐 画面比例控制';
        aspectControlTitle.style.color = 'var(--accent-primary, #d4af37)';
        aspectControlTitle.style.fontSize = '16px';
        aspectControlTitle.style.fontWeight = '700';
        aspectControlTitle.style.marginBottom = '15px';
        aspectControlTitle.style.paddingBottom = '10px';
        aspectControlTitle.style.borderBottom = '2px solid var(--border-color, #4a3f2a)';
        aspectControlTitle.style.textShadow = '0 0 5px rgba(212, 175, 55, 0.5)';
        aspectSection.appendChild(aspectControlTitle);
        
        // 创建比例按钮容器
        const aspectButtonContainer = document.createElement('div');
        aspectButtonContainer.style.display = 'grid';
        aspectButtonContainer.style.gridTemplateColumns = 'repeat(2, 1fr)';
        aspectButtonContainer.style.gap = '8px';
        aspectButtonContainer.style.marginBottom = '15px';
        
        const aspectRatios = [
            { name: '16:9', value: 16/9 },
            { name: '4:3', value: 4/3 },
            { name: '21:9', value: 21/9 },
            { name: '全屏', value: 'fullscreen' }
        ];
        
        aspectRatios.forEach(ratio => {
            const btn = document.createElement('button');
            btn.textContent = ratio.name;
            btn.className = 'ui-button ui-button-secondary';
            btn.style.padding = '6px 12px';
            btn.style.fontSize = '13px';
            btn.addEventListener('click', () => {
                adjustGameAspectRatio(ratio.value);
            });
            aspectButtonContainer.appendChild(btn);
        });
        
        aspectSection.appendChild(aspectButtonContainer);
        
        // 创建自定义比例输入
        const customAspectContainer = document.createElement('div');
        customAspectContainer.style.display = 'flex';
        customAspectContainer.style.alignItems = 'center';
        customAspectContainer.style.gap = '10px';
        customAspectContainer.style.marginBottom = '10px';
        
        const customAspectLabel = document.createElement('span');
        customAspectLabel.textContent = '自定义:';
        customAspectLabel.className = 'control-label';
        customAspectLabel.style.width = 'auto';
        customAspectContainer.appendChild(customAspectLabel);
        
        const customAspectInput = document.createElement('input');
        customAspectInput.type = 'text';
        customAspectInput.placeholder = '宽:高';
        customAspectInput.className = 'ui-input';
        customAspectInput.style.width = '80px';
        customAspectInput.style.fontSize = '13px';
        customAspectContainer.appendChild(customAspectInput);
        
        const applyAspectBtn = document.createElement('button');
        applyAspectBtn.textContent = '应用';
        applyAspectBtn.className = 'ui-button ui-button-success';
        applyAspectBtn.style.padding = '6px 12px';
        applyAspectBtn.style.fontSize = '13px';
        applyAspectBtn.addEventListener('click', () => {
            const input = customAspectInput.value;
            const parts = input.split(':');
            if (parts.length === 2) {
                const width = parseFloat(parts[0]);
                const height = parseFloat(parts[1]);
                if (!isNaN(width) && !isNaN(height) && width > 0 && height > 0) {
                    adjustGameAspectRatio(width / height);
                    showSystemMessage(`画面比例已设置为 ${input}`, 2000);
                } else {
                     showSystemMessage("无效的宽高比格式", 2000);
                }
            } else {
                 showSystemMessage("无效的宽高比格式", 2000);
            }
        });
        customAspectContainer.appendChild(applyAspectBtn);
        
        aspectSection.appendChild(customAspectContainer);

        // 创建性能与画质控制部分
        const performanceSection = document.createElement('div');
        const perfTitle = document.createElement('div');
        perfTitle.textContent = '⚡ 性能与画质';
        perfTitle.style.color = 'var(--accent-primary, #d4af37)';
        perfTitle.style.fontSize = '16px';
        perfTitle.style.fontWeight = '700';
        perfTitle.style.margin = '18px 0 12px 0';
        perfTitle.style.paddingBottom = '10px';
        perfTitle.style.borderBottom = '2px solid var(--border-color, #4a3f2a)';
        perfTitle.style.textShadow = '0 0 5px rgba(212, 175, 55, 0.5)';
        performanceSection.appendChild(perfTitle);

        const perfDesc = document.createElement('div');
        perfDesc.textContent = '不同设备可选择不同画质以提升流畅度（需重启生效）';
        perfDesc.style.color = 'var(--text-tertiary, #b4a481)';
        perfDesc.style.fontSize = '12px';
        perfDesc.style.marginBottom = '10px';
        performanceSection.appendChild(perfDesc);

        const modes = [
            { key: 'high', label: '高质量（高DPI/抗锯齿）' },
            { key: 'balanced', label: '均衡（默认推荐）' },
            { key: 'low', label: '省电（降分辨率/关AA）' },
            { key: 'ultra', label: '极致省电（最低画质）' }
        ];

        const modeContainer = document.createElement('div');
        modeContainer.style.display = 'grid';
        modeContainer.style.gridTemplateColumns = 'repeat(2, 1fr)';
        modeContainer.style.gap = '8px';
        modes.forEach(m => {
            const btn = document.createElement('button');
            btn.textContent = m.label;
            btn.className = 'ui-button ui-button-secondary';
            btn.style.padding = '6px 10px';
            if (typeof performanceMode !== 'undefined' && performanceMode === m.key) {
                btn.classList.add('active');
            }
            btn.addEventListener('click', () => {
                try { localStorage.setItem('ga_performance_mode', m.key); } catch (e) {}
                // 更新按钮状态
                Array.from(modeContainer.children).forEach(child => child.classList.remove('active'));
                btn.classList.add('active');
            });
            modeContainer.appendChild(btn);
        });
        performanceSection.appendChild(modeContainer);

        // 重启按钮
        const restartRow = document.createElement('div');
        restartRow.style.display = 'flex';
        restartRow.style.justifyContent = 'flex-end';
        restartRow.style.gap = '10px';
        restartRow.style.marginTop = '10px';
        const restartHint = document.createElement('div');
        restartHint.textContent = '更改性能模式需要重启画面生效';
        restartHint.style.color = 'var(--text-tertiary, #b4a481)';
        restartHint.style.fontSize = '12px';
        restartRow.appendChild(restartHint);
        const restartBtn = document.createElement('button');
        restartBtn.textContent = '立即重启画面';
        restartBtn.className = 'ui-button ui-button-warning';
        restartBtn.addEventListener('click', () => {
            // 刷新页面，或更优做法是销毁并重建 app；这里简单刷新
            location.reload();
        });
        restartRow.appendChild(restartBtn);
        performanceSection.appendChild(restartRow);

        // 将各部分添加到内容区域
        windowContent.appendChild(bubbleSection);
        windowContent.appendChild(collisionSection);
        windowContent.appendChild(aspectSection);
        windowContent.appendChild(performanceSection);
        
        // 组装窗口
        settingsWindow.appendChild(windowHeader);
        settingsWindow.appendChild(windowContent);
        document.body.appendChild(settingsWindow);
        
        // 实现拖动功能
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        
        windowHeader.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragOffsetX = e.clientX - settingsWindow.offsetLeft;
            dragOffsetY = e.clientY - settingsWindow.offsetTop;
            settingsWindow.style.cursor = 'grabbing';
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const newLeft = e.clientX - dragOffsetX;
            const newTop = e.clientY - dragOffsetY;
            
            // 确保窗口不会被拖出视口
            const maxLeft = window.innerWidth - settingsWindow.offsetWidth;
            const maxTop = window.innerHeight - settingsWindow.offsetHeight;
            
            settingsWindow.style.left = `${Math.max(0, Math.min(newLeft, maxLeft))}px`;
            settingsWindow.style.top = `${Math.max(0, Math.min(newTop, maxTop))}px`;
            
            // 移动后不再居中
            settingsWindow.style.transform = 'none';
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                settingsWindow.style.cursor = 'default';
            }
        });
    }

    // 切换网页模拟面板
    function toggleWebSimPanel() {
        if (webSimPanel) {
            // 清除监控定时器
            if (webSimMonitorInterval) {
                clearInterval(webSimMonitorInterval);
                webSimMonitorInterval = null;
            }
            
            // 清除已显示的记录（下次打开时重新开始）
            displayedWebSims.clear();
            
            document.body.removeChild(webSimPanel);
            webSimPanel = null;
            return;
        }
        
        // 创建网页模拟面板
        webSimPanel = document.createElement('div');
        webSimPanel.id = 'web-sim-panel';
        Object.assign(webSimPanel.style, {
            position: 'fixed',
            top: '60px',
            right: '20px',
            width: '400px',
            maxHeight: '600px',
            backgroundColor: 'var(--bg-primary)',
            border: '2px solid var(--border-color)',
            borderRadius: 'var(--border-radius-lg)',
            boxShadow: 'var(--shadow-lg)',
            zIndex: '10000',
            padding: '20px',
            overflowY: 'auto',
            backdropFilter: 'blur(10px)'
        });
        
        // 面板标题
        const title = document.createElement('div');
        title.textContent = '👽 外星代码模拟';
        Object.assign(title.style, {
            fontSize: '18px',
            fontWeight: 'bold',
            color: 'var(--accent-primary)',
            marginBottom: '15px',
            textAlign: 'center',
            borderBottom: '2px solid var(--border-color)',
            paddingBottom: '10px'
        });
        webSimPanel.appendChild(title);
        
        // 状态显示（替代刷新按钮）
        const statusDisplay = document.createElement('div');
        statusDisplay.id = 'web-sim-status';
        Object.assign(statusDisplay.style, {
            padding: '10px',
            marginBottom: '15px',
            backgroundColor: 'var(--bg-secondary)',
            border: '1px solid var(--border-color-light)',
            borderRadius: 'var(--border-radius-md)',
            textAlign: 'center',
            fontSize: '13px',
            color: 'var(--text-secondary)'
        });
        statusDisplay.textContent = '正在监控网页代码生成...';
        webSimPanel.appendChild(statusDisplay);
        
        // 模拟列表容器
        const listContainer = document.createElement('div');
        listContainer.id = 'web-sim-list-container';
        Object.assign(listContainer.style, {
            minHeight: '100px',
            maxHeight: '400px',
            overflowY: 'auto',
            padding: '10px',
            backgroundColor: 'var(--bg-secondary)',
            borderRadius: 'var(--border-radius-md)',
            border: '1px solid var(--border-color-light)'
        });
        listContainer.innerHTML = '<p style="text-align:center; color: var(--text-tertiary);">等待网页代码生成中...<br><small>代码将在生成时间+30分钟后自动显示</small></p>';
        webSimPanel.appendChild(listContainer);
        
        // 关闭按钮
        const closeButton = document.createElement('button');
        closeButton.innerHTML = '❌';
        closeButton.title = '关闭';
        Object.assign(closeButton.style, {
            position: 'absolute',
            top: '10px',
            right: '10px',
            background: 'none',
            border: 'none',
            fontSize: '16px',
            cursor: 'pointer',
            color: 'var(--text-secondary)',
            padding: '5px'
        });
        closeButton.addEventListener('click', () => {
            toggleWebSimPanel();
        });
        webSimPanel.appendChild(closeButton);
        
        document.body.appendChild(webSimPanel);
        
        // 开始监控网页代码生成
        startWebSimMonitoring();
    }

    // 开始监控网页代码生成
    function startWebSimMonitoring() {
        if (!webSimPanel) return;
        
        const statusDisplay = document.getElementById('web-sim-status');
        if (statusDisplay) {
            statusDisplay.textContent = '正在监控网页代码生成...';
        }
        
        // 清除之前的定时器
        if (webSimMonitorInterval) {
            clearInterval(webSimMonitorInterval);
        }
        
        // 立即检查一次
        checkForNewWebSims();
        
        // 每10秒检查一次新的网页代码
        webSimMonitorInterval = setInterval(() => {
            checkForNewWebSims();
        }, 10000);
    }
    
    // 检查新的网页代码
    function checkForNewWebSims() {
        const listContainer = document.getElementById('web-sim-list-container');
        if (!listContainer) return;
        
        // 获取当前选中的角色名称
        let currentFocusedAgent = Object.keys(personas)[0];
        if (currentLockedCharacter && currentLockedCharacter.textureInfo && currentLockedCharacter.textureInfo.name) {
            if (currentLockedCharacter.textureInfo.name !== 'player') {
                currentFocusedAgent = currentLockedCharacter.textureInfo.name;
            } else if (Object.keys(personas).length > 0) {
                const firstNpcName = Object.keys(personas).find(name => name !== 'player');
                if (firstNpcName) currentFocusedAgent = firstNpcName;
            }
        }
        
        if (!simulation_name || !currentFocusedAgent || currentFocusedAgent === 'player') {
            const statusDisplay = document.getElementById('web-sim-status');
            if (statusDisplay) {
                statusDisplay.textContent = '错误：无法确定当前模拟或角色';
            }
            return;
        }
        
        // 调用Flask API获取HTML文件列表
        const apiUrl = `/list_generated_html_sims/${simulation_name}/${currentFocusedAgent}`;
        
        fetch(apiUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.status === 'success' && data.files && data.files.length > 0) {
                    displayNewWebSimulations(data.files, currentFocusedAgent);
                                 }
            })
            .catch(error => {
                console.error('检查网页模拟失败:', error);
                const statusDisplay = document.getElementById('web-sim-status');
                if (statusDisplay) {
                    statusDisplay.textContent = `检查失败: ${error.message}`;
                }
            });
    }
    
    // 显示新的网页模拟（累积显示）
    function displayNewWebSimulations(files, agentName) {
        const listContainer = document.getElementById('web-sim-list-container');
        if (!listContainer) return;
        
                 // 获取当前模拟时间
         const currentTime = start_datetime;
         
         console.log(`当前模拟时间: ${currentTime.toLocaleString()}`);
         
         // 过滤新文件：只显示应该在当前时间显示的文件
         const newFilesToShow = files.filter(filename => {
             // 如果已经显示过，跳过
             if (displayedWebSims.has(filename)) {
                 return false;
             }
             
             // 解析文件名中的时间，格式：YYYY-MM-DD_HHMMSS.html
             const timeMatch = filename.match(/(\d{4}-\d{2}-\d{2})_(\d{6})\.html$/);
             if (!timeMatch) return false;
             
             const [_, dateStr, timeStr] = timeMatch;
             const hours = timeStr.substring(0, 2);
             const minutes = timeStr.substring(2, 4);
             const seconds = timeStr.substring(4, 6);
             
             // 创建文件对应的时间
             const fileTime = new Date(`${dateStr}T${hours}:${minutes}:${seconds}`);
             
             console.log(`文件 ${filename}：生成时间 ${fileTime.toLocaleString()}`);
             
             // 检查当前模拟时间是否已达到该文件的生成时间
             return currentTime >= fileTime;
         });
        
                 // 更新状态显示
         const statusDisplay = document.getElementById('web-sim-status');
         if (statusDisplay) {
             statusDisplay.textContent = `监控中... 已显示 ${displayedWebSims.size} 个网页代码`;
         }
         
         if (newFilesToShow.length === 0) {
             return;
         }
        
        // 按时间排序（最早的先显示）
        newFilesToShow.sort((a, b) => a.localeCompare(b));
        
        // 如果列表容器为空或只有提示信息，清空它
        if (listContainer.children.length === 0 || 
            (listContainer.children.length === 1 && listContainer.textContent.includes('点击'))) {
            listContainer.innerHTML = '';
        }
        
        // 为每个新文件创建显示项
        newFilesToShow.forEach(filename => {
            const fileItem = document.createElement('div');
            Object.assign(fileItem.style, {
                padding: '12px',
                margin: '8px 0',
                backgroundColor: 'var(--bg-primary)',
                border: '2px solid var(--accent-primary)',
                borderRadius: 'var(--border-radius-md)',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                boxShadow: '0 0 10px rgba(212, 175, 55, 0.3)',
                animation: 'fadeIn 0.5s ease-in-out'
            });
            
            const fileInfo = document.createElement('div');
            Object.assign(fileInfo.style, {
                flex: '1',
                marginRight: '10px'
            });
            
            // 解析文件名中的时间信息
            const timeMatch = filename.match(/(\d{4}-\d{2}-\d{2})_(\d{6})\.html$/);
            const displayTimeText = timeMatch ? 
                `${timeMatch[1]} ${timeMatch[2].substring(0,2)}:${timeMatch[2].substring(2,4)}:${timeMatch[2].substring(4,6)}` : 
                filename;
            
            fileInfo.innerHTML = `
                <div style="font-weight: bold; color: var(--accent-primary); margin-bottom: 4px;">
                    🌟 新生成：${filename}
                </div>
                <div style="font-size: 12px; color: var(--text-secondary);">
                    生成时间: ${displayTimeText}
                </div>
                <div style="font-size: 11px; color: var(--text-tertiary); margin-top: 2px;">
                    角色: ${agentName}
                </div>
            `;
            
            const openButton = document.createElement('button');
            openButton.textContent = '🚀 运行';
            openButton.className = 'ui-button ui-button-success';
            Object.assign(openButton.style, {
                fontSize: '12px',
                padding: '6px 12px',
                minWidth: '60px'
            });
            
            openButton.addEventListener('click', () => {
                const fileUrl = `/static/generated_html_sims/${simulation_name}/${agentName}/${filename}`;
                console.log(`打开网页模拟: ${fileUrl}`);
                window.open(fileUrl, '_blank');
            });
            
            fileItem.appendChild(fileInfo);
            fileItem.appendChild(openButton);
            
            // 添加到列表顶部（最新的在上面）
            if (listContainer.firstChild) {
                listContainer.insertBefore(fileItem, listContainer.firstChild);
            } else {
                listContainer.appendChild(fileItem);
            }
            
            // 标记为已显示
            displayedWebSims.add(filename);
            
                         console.log(`新显示网页代码: ${filename}`);
         });
    }

    // 加载和显示生成的HTML模拟文件列表（根据时间过滤）- 保留兼容性
    function loadWebSimulationsWithTimeFiltering() {
        const listContainer = document.getElementById('web-sim-list-container');
        if (!listContainer) {
            console.error("Web sim list container not found.");
            return;
        }
        listContainer.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;">正在加载列表...</p>';

        // 获取当前选中的角色名称
        let currentFocusedAgent = Object.keys(personas)[0]; // 默认用第一个NPC
        if (currentLockedCharacter && personas[currentLockedCharacter.textureInfo.name]) {
             // 如果有锁定的角色，且该角色是NPC (不是玩家)
             if (currentLockedCharacter.textureInfo.name !== 'player') {
                currentFocusedAgent = currentLockedCharacter.textureInfo.name;
             } else if (Object.keys(personas).length > 0) {
                // 如果锁定的是玩家，使用第一个NPC
                currentFocusedAgent = Object.keys(personas)[0];
             }
        }
        
        console.log(`当前关注的角色: ${currentFocusedAgent}`);
        
        if (!simulation_name || !currentFocusedAgent) {
            listContainer.innerHTML = '<p style="color: var(--text-error);">无法获取当前模拟名称或角色信息</p>';
            return;
        }
        
        // 调用Flask API获取HTML文件列表
        const apiUrl = `/list_generated_html_sims/${simulation_name}/${currentFocusedAgent}`;
        console.log(`调用API: ${apiUrl}`);
        
        fetch(apiUrl)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.status === 'success' && data.files && data.files.length > 0) {
                    displayFilteredWebSimulations(data.files, currentFocusedAgent);
                } else {
                    listContainer.innerHTML = `<p style="color: var(--text-tertiary); text-align: center;">暂无 ${currentFocusedAgent} 的网页模拟文件</p>`;
                }
            })
            .catch(error => {
                console.error('加载网页模拟列表失败:', error);
                listContainer.innerHTML = `<p style="color: var(--text-error);">加载失败: ${error.message}</p>`;
            });
    }
    
    // 显示过滤后的网页模拟
    function displayFilteredWebSimulations(files, agentName) {
        const listContainer = document.getElementById('web-sim-list-container');
        if (!listContainer) return;
        
        // 获取当前模拟时间
        const currentTime = start_datetime;
        const currentTimeString = `${currentTime.getFullYear()}-${String(currentTime.getMonth() + 1).padStart(2, '0')}-${String(currentTime.getDate()).padStart(2, '0')}_${String(currentTime.getHours()).padStart(2, '0')}${String(currentTime.getMinutes()).padStart(2, '0')}00`;
        
        console.log(`当前模拟时间: ${currentTimeString}`);
        
        // 过滤文件：只显示当前时间之前的文件
        const filteredFiles = files.filter(filename => {
            // 从文件名中提取时间信息，假设格式为 YYYY-MM-DD_HHMMSS.html
            const timeMatch = filename.match(/(\\d{4}-\\d{2}-\\d{2})_(\\d{6})\\.html$/);
            if (!timeMatch) return false; // 如果不匹配时间格式，则不显示
            
            const fileTimeString = timeMatch[1] + '_' + timeMatch[2];
            return fileTimeString <= currentTimeString;
        });
        
        if (filteredFiles.length === 0) {
            listContainer.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;">当前时间还没有可用的网页模拟</p>';
            return;
        }
        
        // 按时间排序（最新的在前）
        filteredFiles.sort((a, b) => b.localeCompare(a));
        
        // 创建文件列表
        const fileList = document.createElement('div');
        filteredFiles.forEach(filename => {
            const fileItem = document.createElement('div');
            Object.assign(fileItem.style, {
                padding: '10px',
                margin: '5px 0',
                backgroundColor: 'var(--bg-primary)',
                border: '1px solid var(--border-color-light)',
                borderRadius: 'var(--border-radius-md)',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center'
            });
            
            const fileInfo = document.createElement('div');
            Object.assign(fileInfo.style, {
                flex: '1',
                marginRight: '10px'
            });
            
            // 解析文件名中的时间信息
            const timeMatch = filename.match(/(\\d{4}-\\d{2}-\\d{2})_(\\d{6})\\.html$/);
            const displayTime = timeMatch ? 
                `${timeMatch[1]} ${timeMatch[2].substring(0,2)}:${timeMatch[2].substring(2,4)}:${timeMatch[2].substring(4,6)}` : 
                filename;
            
            fileInfo.innerHTML = `
                <div style="font-weight: bold; color: var(--text-primary);">${filename}</div>
                <div style="font-size: 12px; color: var(--text-secondary);">生成时间: ${displayTime}</div>
            `;
            
            const openButton = document.createElement('button');
            openButton.textContent = '🚀 运行';
            openButton.className = 'ui-button ui-button-primary';
            Object.assign(openButton.style, {
                fontSize: '12px',
                padding: '5px 10px'
            });
            
            openButton.addEventListener('click', () => {
                // 构建静态文件URL
                const fileUrl = `/static/generated_html_sims/${simulation_name}/${agentName}/${filename}`;
                console.log(`打开网页模拟: ${fileUrl}`);
                window.open(fileUrl, '_blank');
            });
            
            fileItem.appendChild(fileInfo);
            fileItem.appendChild(openButton);
            fileList.appendChild(fileItem);
        });
        
        listContainer.innerHTML = '';
        listContainer.appendChild(fileList);
        
        console.log(`显示了 ${filteredFiles.length} 个过滤后的网页模拟文件`);
    }



    // 添加消息队列系统，用于按顺序显示消息
    function toggleDialogBubbles() {
        globalShowDialogBubbles = !globalShowDialogBubbles;
        
        if (globalShowDialogBubbles) {
            // 启用对话气泡显示
            showSystemMessage("💬 NPC对话气泡已启用", 2000);
            console.log("对话气泡显示已启用");
        } else {
            // 禁用对话气泡显示，并隐藏所有当前显示的对话气泡
            showSystemMessage("🚫 NPC对话气泡已禁用", 2000);
            console.log("对话气泡显示已禁用，正在隐藏所有对话气泡");
            
            // 隐藏所有当前显示的对话气泡
            for (let personaName in pronunciatios) {
                const bubble = pronunciatios[personaName];
                if (bubble && bubble.container) {
                    // 只隐藏对话气泡，保留活动气泡
                    if (dialogBubbles[personaName]) {
                        bubble.container.visible = false;
                        
                        // 清除对话气泡相关的计时器和效果
                        if (bubbleTimers[personaName] && bubbleTimers[personaName].dialog) {
                            clearTimeout(bubbleTimers[personaName].dialog);
                            bubbleTimers[personaName].dialog = null;
                        }
                        
                        if (typingEffects[personaName]) {
                            clearInterval(typingEffects[personaName].interval);
                            delete typingEffects[personaName];
                        }
                        
                        delete dialogBubbles[personaName];
                    }
                }
            }
        }
        
        // 更新设置面板中的按钮状态（如果设置面板打开）
        updateDialogBubbleButtonStates();
    }
    
    // 更新设置面板中对话气泡按钮的状态
    function updateDialogBubbleButtonStates() {
        if (settingsWindow) {
            const enableBtn = settingsWindow.querySelector('#settings-enable-dialog-bubbles-btn');
            const disableBtn = settingsWindow.querySelector('#settings-disable-dialog-bubbles-btn');
            if (enableBtn && disableBtn) {
                if (globalShowDialogBubbles) {
                    enableBtn.classList.add('active');
                    disableBtn.classList.remove('active');
                } else {
                    enableBtn.classList.remove('active');
                    disableBtn.classList.add('active');
                }
            }
        }
    }

    // 键盘控制 - 增强版本，支持快捷键
    function setupKeyboardControls() {
        window.addEventListener('keydown', (e) => {
            keyboard[e.key] = true;
            
            // 处理对话气泡切换快捷键 (支持自定义按键)
            if (e.key.toLowerCase() === dialogBubbleToggleKey.toLowerCase() && !isDialogBubbleKeyPressed) {
                e.preventDefault();
                isDialogBubbleKeyPressed = true;
                toggleDialogBubbles();
            }
            
            // 添加快捷键支持
            if (e.ctrlKey || e.metaKey) {
                switch(e.key.toLowerCase()) {
                    case ' ': // Ctrl+Space 暂停/运行
                        e.preventDefault();
                        if (finished) return;
                        if (paused) {
                            buttonPlay.click();
                        } else {
                            buttonPause.click();
                        }
                        break;
                    case 'd': // Ctrl+D 显示/隐藏对话面板
                        e.preventDefault();
                        if (buttonShowConversation.style.display === 'none') {
                            buttonHideConversation.click();
                        } else {
                            buttonShowConversation.click();
                        }
                        break;
                    case 's': // Ctrl+S 打开设置
                        e.preventDefault();
                        toggleSettingsWindow();
                        break;
                }
            }
            
            // ESC键隐藏浮动窗口
            if (e.key === 'Escape') {
                if (settingsWindow) {
                    toggleSettingsWindow();
                }
                if (floatingClockWindow) {
                    toggleFloatingClock();
                }
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keyboard[e.key] = false;
            
            // 重置对话气泡按键状态
            if (e.key.toLowerCase() === dialogBubbleToggleKey.toLowerCase()) {
                isDialogBubbleKeyPressed = false;
            }
        });
        
        // 显示快捷键提示
        showSystemMessage(`快捷键: Ctrl+Space(运行/暂停) Ctrl+D(对话面板) ${dialogBubbleToggleKey.toUpperCase()}键(NPC对话气泡) Ctrl+S(设置) ESC(关闭窗口)`, 5000);
    }

    // 全局变量存储网页模拟数据和状态
    let webSimData = {
        allAgents: {}, // 存储所有智能体的模拟文件信息
        displayedFiles: new Set(), // 已显示的文件（格式："智能体名:文件名"）
        updateTimer: null, // 更新定时器
        isLoaded: false, // 数据是否已加载
        currentSimName: null // 当前模拟名称
    };

    // 显示/隐藏网页模拟面板
    async function toggleWebSimPanel() {
        if (webSimPanel) {
            // 如果已存在，则移除面板并清除定时器
            document.body.removeChild(webSimPanel);
            webSimPanel = null;
            if (webSimData.updateTimer) {
                clearInterval(webSimData.updateTimer);
                webSimData.updateTimer = null;
            }
            return;
        }
        
        // 获取当前模拟名称
        if (!simulation_name) {
            showSystemMessage('❌ 无法获取当前模拟名称', 3000);
            console.error('无法获取当前模拟名称');
            return;
        }
        
        webSimData.currentSimName = simulation_name;
        
        // 创建网页模拟面板
        webSimPanel = document.createElement('div');
        webSimPanel.className = 'floating-window';
        webSimPanel.style.width = '450px';
        webSimPanel.style.left = '50%';
        webSimPanel.style.top = '100px';
        webSimPanel.style.transform = 'translateX(-50%)';
        webSimPanel.style.maxHeight = 'calc(100vh - 200px)';
        webSimPanel.style.overflowY = 'auto';
        
        // 窗口头部
        const windowHeader = document.createElement('div');
        windowHeader.className = 'window-header';
        
        const windowTitle = document.createElement('div');
        windowTitle.className = 'window-title';
        windowTitle.textContent = '👽 外星代码模拟';
        
        const closeButton = document.createElement('button');
        closeButton.className = 'window-close';
        closeButton.innerHTML = '×';
        closeButton.addEventListener('click', () => {
            toggleWebSimPanel();
        });
        
        windowHeader.appendChild(windowTitle);
        windowHeader.appendChild(closeButton);
        
        // 窗口内容容器
        const windowContent = document.createElement('div');
        windowContent.className = 'window-content';
        
        // 创建当前时间显示
        const timeInfo = document.createElement('div');
        timeInfo.id = 'web-sim-time-info';
        timeInfo.style.marginBottom = '15px';
        timeInfo.style.padding = '10px';
        timeInfo.style.background = 'rgba(212, 175, 55, 0.1)';
        timeInfo.style.borderRadius = 'var(--border-radius-sm)';
        timeInfo.style.textAlign = 'center';
        
        const currentTime = new Date(start_datetime);
        const timeString = `${currentTime.getFullYear()}-${(currentTime.getMonth()+1).toString().padStart(2,'0')}-${currentTime.getDate().toString().padStart(2,'0')} ${currentTime.getHours().toString().padStart(2,'0')}:${currentTime.getMinutes().toString().padStart(2,'0')}`;
        timeInfo.innerHTML = `<strong>当前模拟时间:</strong><br>${timeString}`;
        windowContent.appendChild(timeInfo);
        
        // 创建模拟列表容器
        const listContainer = document.createElement('div');
        listContainer.id = 'web-sim-list-container';
        listContainer.style.minHeight = '200px';
        listContainer.style.maxHeight = '350px';
        listContainer.style.overflowY = 'auto';
        listContainer.style.padding = '10px';
        listContainer.style.background = 'rgba(0,0,0,0.1)';
        listContainer.style.borderRadius = 'var(--border-radius-sm)';
        listContainer.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;">正在加载数据...</p>';
        windowContent.appendChild(listContainer);
        
        // 组装窗口
        webSimPanel.appendChild(windowHeader);
        webSimPanel.appendChild(windowContent);
        document.body.appendChild(webSimPanel);
        
        // 实现拖动功能
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        
        windowHeader.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragOffsetX = e.clientX - webSimPanel.offsetLeft;
            dragOffsetY = e.clientY - webSimPanel.offsetTop;
            webSimPanel.style.cursor = 'grabbing';
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const newLeft = e.clientX - dragOffsetX;
            const newTop = e.clientY - dragOffsetY;
            
            const maxLeft = window.innerWidth - webSimPanel.offsetWidth;
            const maxTop = window.innerHeight - webSimPanel.offsetHeight;
            
            webSimPanel.style.left = `${Math.max(0, Math.min(newLeft, maxLeft))}px`;
            webSimPanel.style.top = `${Math.max(0, Math.min(newTop, maxTop))}px`;
            webSimPanel.style.transform = 'none';
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                webSimPanel.style.cursor = 'default';
            }
        });
        
        // 预加载所有智能体的模拟文件数据
        await loadAllAgentsWebSims();
        
        // 设置定时更新（每秒检查一次）
        webSimData.updateTimer = setInterval(() => {
            if (webSimPanel) {
                updateWebSimDisplay();
            }
        }, 1000);
    }
    
    // 解析HTML文件名中的时间戳
    function parseHtmlFileTime(fileName) {
        // 文件名格式: YYYY-MM-DD_HHMMSS.html
        const timeMatch = fileName.match(/(\d{4}-\d{2}-\d{2})_(\d{2})(\d{2})(\d{2})\.html$/);
        if (timeMatch) {
            const [_, dateStr, hours, minutes, seconds] = timeMatch;
            const timeStr = `${hours}:${minutes}:${seconds}`;
            return new Date(`${dateStr}T${timeStr}`);
        }
        return null;
    }
    
    // 预加载所有智能体的模拟文件数据
    async function loadAllAgentsWebSims() {
        if (!webSimData.currentSimName) {
            console.error('无法获取当前模拟名称');
            return false;
        }
        
        const listContainer = document.getElementById('web-sim-list-container');
        if (listContainer) {
            listContainer.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;">正在加载数据...</p>';
        }
        
        try {
            // 获取所有智能体列表
            const agentNames = Object.keys(personas).filter(name => name !== 'player');
            if (agentNames.length === 0) {
                throw new Error('未找到任何智能体');
            }
            
            // 清空现有数据
            webSimData.allAgents = {};
            webSimData.displayedFiles.clear();
            
            // 为每个智能体加载模拟文件
            for (const agentName of agentNames) {
                try {
                    const response = await fetch(`/list_generated_html_sims/${webSimData.currentSimName}/${agentName}`);
                    if (!response.ok) {
                        console.warn(`获取智能体 ${agentName} 的模拟文件失败: HTTP ${response.status}`);
                        continue;
                    }
                    
                    const data = await response.json();
                    if (data.error) {
                        console.warn(`获取智能体 ${agentName} 的模拟文件失败: ${data.error}`);
                        continue;
                    }
                    
                    if (data.files && data.files.length > 0) {
                        webSimData.allAgents[agentName] = data.files;
                        console.log(`已加载智能体 ${agentName} 的 ${data.files.length} 个模拟文件`);
                    }
                } catch (agentError) {
                    console.warn(`加载智能体 ${agentName} 的模拟文件时出错:`, agentError);
                }
            }
            
            // 检查是否成功加载了任何数据
            const totalAgents = Object.keys(webSimData.allAgents).length;
            const totalFiles = Object.values(webSimData.allAgents).reduce((sum, files) => sum + files.length, 0);
            
            if (totalAgents === 0) {
                throw new Error('未找到任何智能体的模拟文件');
            }
            
            console.log(`成功加载 ${totalAgents} 个智能体的共 ${totalFiles} 个模拟文件`);
            webSimData.isLoaded = true;
            
            // 立即更新显示
            updateWebSimDisplay();
            return true;
            
        } catch (error) {
            console.error('加载所有智能体的模拟文件失败:', error);
            if (listContainer) {
                listContainer.innerHTML = `<p style="color: var(--accent-error); text-align: center;">加载失败: ${error.message}</p>`;
            }
            return false;
        }
    }
    
    // 更新网页模拟显示
    function updateWebSimDisplay() {
        if (!webSimPanel || !webSimData.isLoaded) return;
        
        const listContainer = document.getElementById('web-sim-list-container');
        const timeInfo = document.getElementById('web-sim-time-info');
        
        if (!listContainer || !timeInfo) return;
        
        // 更新时间显示
        const currentTime = new Date(start_datetime);
        const timeString = `${currentTime.getFullYear()}-${(currentTime.getMonth()+1).toString().padStart(2,'0')}-${currentTime.getDate().toString().padStart(2,'0')} ${currentTime.getHours().toString().padStart(2,'0')}:${currentTime.getMinutes().toString().padStart(2,'0')}`;
        timeInfo.innerHTML = `<strong>当前模拟时间:</strong><br>${timeString}`;
        
        // 检查是否有新文件需要显示
        let hasNewFiles = false;
        const newFilesToShow = [];
        
        // 遍历所有智能体的文件
        Object.keys(webSimData.allAgents).forEach(agentName => {
            const files = webSimData.allAgents[agentName] || [];
            
            files.forEach(fileName => {
                const fileKey = `${agentName}:${fileName}`;
                if (webSimData.displayedFiles.has(fileKey)) return; // 已显示过的文件跳过
                
                const fileTime = parseHtmlFileTime(fileName);
                if (fileTime && fileTime.getTime() <= currentTime.getTime()) {
                    newFilesToShow.push({ agentName, fileName, fileTime });
                    hasNewFiles = true;
                }
            });
        });
        
        // 如果有新文件，添加到显示列表
        if (hasNewFiles) {
            // 按时间排序（最新的在前）
            newFilesToShow.sort((a, b) => b.fileTime - a.fileTime);
            
            // 如果是第一次显示文件，清空容器
            if (webSimData.displayedFiles.size === 0) {
                listContainer.innerHTML = '';
            }
            
            // 添加新文件到显示列表
            newFilesToShow.forEach(({ agentName, fileName, fileTime }) => {
                const fileKey = `${agentName}:${fileName}`;
                addWebSimFileToDisplay(listContainer, agentName, fileName, fileTime);
                webSimData.displayedFiles.add(fileKey);
            });
            
            console.log(`新显示 ${newFilesToShow.length} 个网页模拟文件`);
        } else if (webSimData.displayedFiles.size === 0) {
            // 如果没有文件可显示，显示等待提示
            listContainer.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;">等待模拟时间到达...</p>';
        }
    }
    
    // 添加文件到显示列表
    function addWebSimFileToDisplay(container, agentName, fileName, fileTime) {
        // 创建文件项容器
        const fileItem = document.createElement('div');
        fileItem.className = 'web-sim-file-item';
        fileItem.style.padding = '12px';
        fileItem.style.margin = '10px 0';
        fileItem.style.backgroundColor = 'var(--bg-secondary)';
        fileItem.style.border = '1px solid var(--border-color)';
        fileItem.style.borderRadius = 'var(--border-radius-md)';
        fileItem.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
        fileItem.style.animation = 'fadeIn 0.5s ease-out';
        fileItem.style.display = 'flex';
        fileItem.style.flexDirection = 'column';
        fileItem.style.gap = '8px';
        
        // 创建头部信息（智能体名称和时间）
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.style.alignItems = 'center';
        header.style.marginBottom = '5px';
        
        // 智能体名称标签
        const agentLabel = document.createElement('div');
        agentLabel.style.backgroundColor = 'rgba(212, 175, 55, 0.2)';
        agentLabel.style.color = 'var(--accent-primary)';
        agentLabel.style.padding = '3px 8px';
        agentLabel.style.borderRadius = 'var(--border-radius-sm)';
        agentLabel.style.fontSize = '12px';
        agentLabel.style.fontWeight = 'bold';
        agentLabel.textContent = `👤 ${agentName}`;
        header.appendChild(agentLabel);
        
        // 时间标签
        const timeLabel = document.createElement('div');
        timeLabel.style.color = 'var(--text-tertiary)';
        timeLabel.style.fontSize = '11px';
        timeLabel.textContent = fileTime.toLocaleString('zh-CN', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
        header.appendChild(timeLabel);
        
        fileItem.appendChild(header);
        
        // 文件名信息
        const fileNameInfo = document.createElement('div');
        fileNameInfo.style.fontSize = '13px';
        fileNameInfo.style.color = 'var(--text-primary)';
        fileNameInfo.style.wordBreak = 'break-all';
        fileNameInfo.textContent = fileName;
        fileItem.appendChild(fileNameInfo);
        
        // 打开按钮
        const openButton = document.createElement('button');
        openButton.textContent = '🚀 运行模拟';
        openButton.className = 'ui-button ui-button-success';
        openButton.style.marginTop = '5px';
        openButton.style.padding = '6px 12px';
        openButton.style.fontSize = '12px';
        openButton.onclick = function() {
            const fileUrl = `/static/generated_html_sims/${webSimData.currentSimName}/${agentName}/${fileName}`;
            window.open(fileUrl, '_blank');
        };
        fileItem.appendChild(openButton);
        
        // 添加到列表顶部（最新的在上面）
        if (container.firstChild) {
            container.insertBefore(fileItem, container.firstChild);
        } else {
            container.appendChild(fileItem);
        }
    }

    // 音乐数据管理对象
    const musicData = {
        currentSimName: null,
        allAgents: {}, // 存储所有智能体的音乐文件
        displayedFiles: new Set(), // 已显示的文件
        isLoaded: false,
        updateTimer: null
    };
    
    // 切换音乐面板显示/隐藏
    async function toggleMusicPanel() {
        if (musicPanel) {
            // 如果已存在，则移除面板并清除定时器
            document.body.removeChild(musicPanel);
            musicPanel = null;
            if (musicData.updateTimer) {
                clearInterval(musicData.updateTimer);
                musicData.updateTimer = null;
            }
            return;
        }
        
        // 获取当前模拟名称
        if (!simulation_name) {
            showSystemMessage('❌ 无法获取当前模拟名称', 3000);
            console.error('无法获取当前模拟名称');
            return;
        }
        
        musicData.currentSimName = simulation_name;
        
        // 创建音乐面板
        musicPanel = document.createElement('div');
        musicPanel.className = 'floating-window';
        musicPanel.style.width = '450px';
        musicPanel.style.left = '50%';
        musicPanel.style.top = '120px';
        musicPanel.style.transform = 'translateX(-50%)';
        musicPanel.style.maxHeight = 'calc(100vh - 240px)';
        musicPanel.style.overflowY = 'auto';
        
        // 窗口头部
        const windowHeader = document.createElement('div');
        windowHeader.className = 'window-header';
        
        const windowTitle = document.createElement('div');
        windowTitle.className = 'window-title';
        windowTitle.textContent = '🎵 外星音乐';
        
        const closeButton = document.createElement('button');
        closeButton.className = 'window-close';
        closeButton.innerHTML = '×';
        closeButton.addEventListener('click', () => {
            toggleMusicPanel();
        });
        
        windowHeader.appendChild(windowTitle);
        windowHeader.appendChild(closeButton);
        
        // 窗口内容容器
        const windowContent = document.createElement('div');
        windowContent.className = 'window-content';
        
        // 创建当前时间显示
        const timeInfo = document.createElement('div');
        timeInfo.id = 'music-time-info';
        timeInfo.style.marginBottom = '15px';
        timeInfo.style.padding = '10px';
        timeInfo.style.background = 'rgba(147, 112, 219, 0.1)';
        timeInfo.style.borderRadius = 'var(--border-radius-sm)';
        timeInfo.style.textAlign = 'center';
        
        const currentTime = new Date(start_datetime);
        const timeString = `${currentTime.getFullYear()}-${(currentTime.getMonth()+1).toString().padStart(2,'0')}-${currentTime.getDate().toString().padStart(2,'0')} ${currentTime.getHours().toString().padStart(2,'0')}:${currentTime.getMinutes().toString().padStart(2,'0')}`;
        timeInfo.innerHTML = `<strong>当前模拟时间:</strong><br>${timeString}`;
        windowContent.appendChild(timeInfo);
        
        // 创建音乐列表容器
        const listContainer = document.createElement('div');
        listContainer.id = 'music-list-container';
        listContainer.style.minHeight = '200px';
        listContainer.style.maxHeight = '350px';
        listContainer.style.overflowY = 'auto';
        listContainer.style.padding = '10px';
        listContainer.style.background = 'rgba(0,0,0,0.1)';
        listContainer.style.borderRadius = 'var(--border-radius-sm)';
        listContainer.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;">正在加载音乐数据...</p>';
        windowContent.appendChild(listContainer);
        
        // 组装窗口
        musicPanel.appendChild(windowHeader);
        musicPanel.appendChild(windowContent);
        document.body.appendChild(musicPanel);
        
        // 实现拖动功能
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        
        windowHeader.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragOffsetX = e.clientX - musicPanel.offsetLeft;
            dragOffsetY = e.clientY - musicPanel.offsetTop;
            musicPanel.style.cursor = 'grabbing';
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const newLeft = e.clientX - dragOffsetX;
            const newTop = e.clientY - dragOffsetY;
            
            const maxLeft = window.innerWidth - musicPanel.offsetWidth;
            const maxTop = window.innerHeight - musicPanel.offsetHeight;
            
            musicPanel.style.left = `${Math.max(0, Math.min(newLeft, maxLeft))}px`;
            musicPanel.style.top = `${Math.max(0, Math.min(newTop, maxTop))}px`;
            musicPanel.style.transform = 'none';
        });
        
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                musicPanel.style.cursor = 'default';
            }
        });
        
        // 预加载所有智能体的音乐文件数据
        await loadAllAgentsMusic();
        
        // 设置定时更新（每秒检查一次）
        musicData.updateTimer = setInterval(() => {
            if (musicPanel) {
                updateMusicDisplay();
            }
        }, 1000);
    }
    
    // 解析音乐文件名中的时间戳
    function parseMusicFileTime(fileName) {
        // 文件名格式: YYYY-MM-DD_HHMMSS_hash.mp3
        const timeMatch = fileName.match(/(\d{4}-\d{2}-\d{2})_(\d{2})(\d{2})(\d{2})_[a-f0-9]+\.mp3$/);
        if (timeMatch) {
            const [_, dateStr, hours, minutes, seconds] = timeMatch;
            const timeStr = `${hours}:${minutes}:${seconds}`;
            return new Date(`${dateStr}T${timeStr}`);
        }
        return null;
    }
    
    // 预加载所有智能体的音乐文件数据
    async function loadAllAgentsMusic() {
        if (!musicData.currentSimName) {
            console.error('无法获取当前模拟名称');
            return false;
        }
        
        const listContainer = document.getElementById('music-list-container');
        if (listContainer) {
            listContainer.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;">正在加载音乐数据...</p>';
        }
        
        try {
            // 获取所有智能体列表
            const agentNames = Object.keys(personas).filter(name => name !== 'player');
            if (agentNames.length === 0) {
                throw new Error('未找到任何智能体');
            }
            
            // 清空现有数据
            musicData.allAgents = {};
            musicData.displayedFiles.clear();
            
            // 为每个智能体加载音乐文件
            for (const agentName of agentNames) {
                try {
                    const response = await fetch(`/list_generated_music/${musicData.currentSimName}/${agentName}`);
                    if (!response.ok) {
                        console.warn(`获取智能体 ${agentName} 的音乐文件失败: HTTP ${response.status}`);
                        continue;
                    }
                    
                    const data = await response.json();
                    if (data.error) {
                        console.warn(`获取智能体 ${agentName} 的音乐文件失败: ${data.error}`);
                        continue;
                    }
                    
                    if (data.files && data.files.length > 0) {
                        musicData.allAgents[agentName] = data.files;
                        console.log(`已加载智能体 ${agentName} 的 ${data.files.length} 个音乐文件`);
                    }
                } catch (agentError) {
                    console.warn(`加载智能体 ${agentName} 的音乐文件时出错:`, agentError);
                }
            }
            
            // 检查是否成功加载了任何数据
            const totalAgents = Object.keys(musicData.allAgents).length;
            const totalFiles = Object.values(musicData.allAgents).reduce((sum, files) => sum + files.length, 0);
            
            if (totalAgents === 0) {
                throw new Error('未找到任何智能体的音乐文件');
            }
            
            console.log(`成功加载 ${totalAgents} 个智能体的共 ${totalFiles} 个音乐文件`);
            musicData.isLoaded = true;
            
            // 立即更新显示
            updateMusicDisplay();
            return true;
            
        } catch (error) {
            console.error('加载所有智能体的音乐文件失败:', error);
            if (listContainer) {
                listContainer.innerHTML = `<p style="color: var(--accent-error); text-align: center;">加载失败: ${error.message}</p>`;
            }
            return false;
        }
    }
    
    // 更新音乐显示
    function updateMusicDisplay() {
        if (!musicPanel || !musicData.isLoaded) return;
        
        const listContainer = document.getElementById('music-list-container');
        const timeInfo = document.getElementById('music-time-info');
        
        if (!listContainer || !timeInfo) return;
        
        // 更新时间显示
        const currentTime = new Date(start_datetime);
        const timeString = `${currentTime.getFullYear()}-${(currentTime.getMonth()+1).toString().padStart(2,'0')}-${currentTime.getDate().toString().padStart(2,'0')} ${currentTime.getHours().toString().padStart(2,'0')}:${currentTime.getMinutes().toString().padStart(2,'0')}`;
        timeInfo.innerHTML = `<strong>当前模拟时间:</strong><br>${timeString}`;
        
        // 检查是否有新文件需要显示
        let hasNewFiles = false;
        const newFilesToShow = [];
        
        // 遍历所有智能体的文件
        Object.keys(musicData.allAgents).forEach(agentName => {
            const files = musicData.allAgents[agentName] || [];
            
            files.forEach(fileName => {
                const fileKey = `${agentName}:${fileName}`;
                if (musicData.displayedFiles.has(fileKey)) return; // 已显示过的文件跳过
                
                const fileTime = parseMusicFileTime(fileName);
                if (fileTime && fileTime.getTime() <= currentTime.getTime()) {
                    newFilesToShow.push({ agentName, fileName, fileTime });
                    hasNewFiles = true;
                }
            });
        });
        
        // 如果有新文件，添加到显示列表
        if (hasNewFiles) {
            // 按时间排序（最新的在前）
            newFilesToShow.sort((a, b) => b.fileTime - a.fileTime);
            
            // 如果是第一次显示文件，清空容器
            if (musicData.displayedFiles.size === 0) {
                listContainer.innerHTML = '';
            }
            
            // 添加新文件到显示列表
            newFilesToShow.forEach(({ agentName, fileName, fileTime }) => {
                const fileKey = `${agentName}:${fileName}`;
                addMusicFileToDisplay(listContainer, agentName, fileName, fileTime);
                musicData.displayedFiles.add(fileKey);
            });
            
            console.log(`新显示 ${newFilesToShow.length} 个音乐文件`);
        } else if (musicData.displayedFiles.size === 0) {
            // 如果没有文件可显示，显示等待提示
            listContainer.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;">等待模拟时间到达...</p>';
        }
    }
    
    // 添加音乐文件到显示列表
    function addMusicFileToDisplay(container, agentName, fileName, fileTime) {
        // 创建文件项容器
        const fileItem = document.createElement('div');
        fileItem.className = 'music-file-item';
        fileItem.style.padding = '12px';
        fileItem.style.margin = '10px 0';
        fileItem.style.backgroundColor = 'var(--bg-secondary)';
        fileItem.style.border = '1px solid var(--border-color)';
        fileItem.style.borderRadius = 'var(--border-radius-md)';
        fileItem.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
        fileItem.style.animation = 'fadeIn 0.5s ease-out';
        fileItem.style.display = 'flex';
        fileItem.style.flexDirection = 'column';
        fileItem.style.gap = '8px';
        
        // 创建头部信息（智能体名称和时间）
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.justifyContent = 'space-between';
        header.style.alignItems = 'center';
        header.style.marginBottom = '5px';
        
        // 智能体名称标签
        const agentLabel = document.createElement('div');
        agentLabel.style.backgroundColor = 'rgba(147, 112, 219, 0.2)';
        agentLabel.style.color = '#9370db';
        agentLabel.style.padding = '3px 8px';
        agentLabel.style.borderRadius = 'var(--border-radius-sm)';
        agentLabel.style.fontSize = '12px';
        agentLabel.style.fontWeight = 'bold';
        agentLabel.textContent = `🎤 ${agentName}`;
        header.appendChild(agentLabel);
        
        // 时间标签
        const timeLabel = document.createElement('div');
        timeLabel.style.color = 'var(--text-tertiary)';
        timeLabel.style.fontSize = '11px';
        timeLabel.textContent = fileTime.toLocaleString('zh-CN', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
        header.appendChild(timeLabel);
        
        fileItem.appendChild(header);
        
        // 文件名信息
        const fileNameInfo = document.createElement('div');
        fileNameInfo.style.fontSize = '13px';
        fileNameInfo.style.color = 'var(--text-primary)';
        fileNameInfo.style.wordBreak = 'break-all';
        fileNameInfo.textContent = fileName;
        fileItem.appendChild(fileNameInfo);
        
        // 音频播放器
        const audioPlayer = document.createElement('audio');
        audioPlayer.controls = true;
        audioPlayer.style.width = '100%';
        audioPlayer.style.marginTop = '5px';
        const audioUrl = `/static/generated_music/${musicData.currentSimName}/${agentName}/${fileName}`;
        audioPlayer.src = audioUrl;
        audioPlayer.preload = 'metadata';
        
        // 添加播放事件监听器，实现单一播放功能
        audioPlayer.addEventListener('play', function() {
            // 暂停所有其他正在播放的音频
            const allAudioPlayers = document.querySelectorAll('.music-file-item audio');
            allAudioPlayers.forEach(function(otherPlayer) {
                if (otherPlayer !== audioPlayer && !otherPlayer.paused) {
                    otherPlayer.pause();
                }
            });
        });
        
        fileItem.appendChild(audioPlayer);
        
        // 添加到列表顶部（最新的在上面）
        if (container.firstChild) {
            container.insertBefore(fileItem, container.firstChild);
        } else {
            container.appendChild(fileItem);
        }
    }

    // 键盘控制 - 增强版本，支持快捷键
</script>


